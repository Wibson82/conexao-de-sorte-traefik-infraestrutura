name: � Autenticacao - CI/CD Pipeline (Self-hosted Runners)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Destino do deploy'
        required: false
        default: 'production'
        type: choice
        options: [staging, production]

env:
  SERVICE_NAME: autenticacao
  TZ: America/Sao_Paulo

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: false

jobs:
  validate-environment:
    runs-on: ubuntu-latest
    timeout-minutes: 20 # Step timeouts: 10 + 10
    name: ✅ Validate Build Environment
    steps:
      - uses: actions/checkout@v4
      - name: "Guard: forbid r2dbc:h2 outside tests"
        timeout-minutes: 10
        run: |
          set -euo pipefail
          FOUND=$(grep -R --line-number --include='*.yml' --include='*.properties' --include='*.yaml' "r2dbc:h2" src || true)
          if echo "$FOUND" | grep -v "src/test/" | grep -q "r2dbc:h2"; then
            echo "Forbidden r2dbc:h2 reference outside src/test" >&2
            echo "$FOUND" | grep -v "src/test/" >&2 || true
            exit 1
          fi
      - name: "Guard: H2 not in non-test scopes"
        timeout-minutes: 10
        run: |
          set -euo pipefail
          mvn -B -q dependency:list -DincludeScope=compile -DoutputFile=dep.txt -DappendOutput=true || true
          if grep -E "com.h2database:h2|io.r2dbc:r2dbc-h2" dep.txt; then
            echo "H2 present in non-test scope (compile/runtime)" >&2
            exit 1
          fi
  build-and-test:
    needs: validate-environment
    runs-on: ubuntu-latest
    timeout-minutes: 40 # Step timeouts: 10 + 10 + 10 + 10
    name: �️ Build and Test on GitHub Runners
    steps:
      - uses: actions/checkout@v4
      - name: Setup Java 24
        timeout-minutes: 10
        uses: actions/setup-java@v4
        with:
          java-version: '24'
          distribution: 'temurin'
          cache: maven
      - name: Verify Maven wrapper
        timeout-minutes: 10
        run: |
          chmod +x ./mvnw
          ./mvnw --version
      - name: Build application (skip tests)
        timeout-minutes: 10
        run: ./mvnw clean package -DskipTests
      - name: Upload JAR artifact for self-hosted runner
        timeout-minutes: 10
        uses: actions/upload-artifact@v4
        with:
          name: autenticacao-jar
          path: target/*.jar
          retention-days: 1

  build-deploy-selfhosted:
    runs-on: [self-hosted, Linux, X64, conexao, conexao-de-sorte-backend-autenticacao]
    timeout-minutes: 100 # Step timeouts: 10 + 10 + 10 + 10 + 10 + 30 + 10 + 10
    name: � Build & Deploy on Self-hosted Runner (Ubuntu)
    needs: build-and-test
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'production'))
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      
      - name: Verificar ambiente do self-hosted runner
        timeout-minutes: 10
        run: |
          echo "� Verificando ambiente do self-hosted runner..."
          echo "� Runner: $(hostname)"
          echo "� Data: $(date)"
          echo "� Usuário: $(whoami)"
          echo "� Diretório: $(pwd)"
          echo "� Espaço disponível:"
          df -h
          echo "� Docker version:"
          docker --version
          echo "☕ Java version:"
          java -version || echo "Java não encontrado via PATH"
          
      - name: Download JAR artifact from GitHub runners
        timeout-minutes: 10
        uses: actions/download-artifact@v4
        with:
          name: autenticacao-jar
          path: ./target
          
      - name: Azure Login (OIDC) no self-hosted runner
        timeout-minutes: 10
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Fetch Azure Key Vault secrets
        id: kv
        timeout-minutes: 10
        shell: bash
        run: |
          set -euo pipefail
          VAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          if [[ "$VAULT_ENDPOINT" =~ https://([^.]+)\.vault\.azure\.net ]]; then
            VAULT="${BASH_REMATCH[1]}"
          else
            echo "ERROR: Invalid AZURE_KEYVAULT_ENDPOINT format: $VAULT_ENDPOINT" >&2
            exit 1
          fi
          
          echo "Loading secrets from Azure Key Vault: $VAULT" >&2
          get() { 
            echo "Fetching secret: $1" >&2
            SECRET_VALUE=$(az keyvault secret show --vault-name "$VAULT" --name "$1" --query value -o tsv 2>/dev/null)
            if [ $? -ne 0 ] || [ -z "$SECRET_VALUE" ]; then
              echo "ERROR: Secret $1 not found in Azure Key Vault $VAULT" >&2
              exit 1
            fi
            echo "$SECRET_VALUE"
          }
          
          # Common secrets
          echo "REDIS_HOST=$(get conexao-de-sorte-redis-host)" >> $GITHUB_ENV
          echo "REDIS_PORT=$(get conexao-de-sorte-redis-port)" >> $GITHUB_ENV
          echo "REDIS_PASSWORD=$(get conexao-de-sorte-redis-password)" >> $GITHUB_ENV
          echo "JWT_ISSUER=$(get conexao-de-sorte-jwt-issuer)" >> $GITHUB_ENV
          echo "JWT_JWKS_URI=$(get conexao-de-sorte-jwt-jwks-uri)" >> $GITHUB_ENV
          echo "DB_HOST=$(get conexao-de-sorte-database-host)" >> $GITHUB_ENV
          echo "DB_PORT=$(get conexao-de-sorte-database-port)" >> $GITHUB_ENV
          echo "DB_USERNAME=$(get conexao-de-sorte-database-username)" >> $GITHUB_ENV
          echo "DB_PASSWORD=$(get conexao-de-sorte-database-password)" >> $GITHUB_ENV
          echo "JWT_SIGNING_KEY=$(get conexao-de-sorte-jwt-signing-key)" >> $GITHUB_ENV
          echo "JWT_VERIFICATION_KEY=$(get conexao-de-sorte-jwt-verification-key)" >> $GITHUB_ENV
          echo "JWT_KEY_ID=$(get conexao-de-sorte-jwt-key-id)" >> $GITHUB_ENV
          echo "ENCRYPTION_MASTER_KEY=$(get conexao-de-sorte-encryption-master-key)" >> $GITHUB_ENV
          echo "ENCRYPTION_BACKUP_KEY=$(get conexao-de-sorte-encryption-backup-key)" >> $GITHUB_ENV
          echo "SSL_KEYSTORE_PASSWORD=$(get conexao-de-sorte-ssl-keystore-password)" >> $GITHUB_ENV
          echo "CORS_ALLOWED_ORIGINS=$(get conexao-de-sorte-cors-allowed-origins)" >> $GITHUB_ENV
          
          echo "✅ Azure Key Vault secrets loaded successfully" >&2
          
      - name: � Clean old containers
        timeout-minutes: 10
        run: |
          set -euo pipefail
          CONTAINER_NAME="${{ env.SERVICE_NAME }}-microservice"
          echo "� Cleaning old $CONTAINER_NAME containers..."
          
          if docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"; then
            echo "� Stopping container: $CONTAINER_NAME"
            docker stop "$CONTAINER_NAME" || true
            echo "�️ Removing container: $CONTAINER_NAME"
            docker rm "$CONTAINER_NAME" || true
          else
            echo "✅ No $CONTAINER_NAME container found"
          fi
          
          docker images --format "{{.Repository}}:{{.Tag}}" | grep "^${{ env.SERVICE_NAME }}:" | head -n -1 | xargs -r docker rmi || true
          echo "✅ Container cleanup completed"
      - name: � Build Docker image (Local - Self-hosted)
        id: build
        timeout-minutes: 30
        run: |
          set -euo pipefail
          TAG="${{ env.SERVICE_NAME }}:$(date +'%Y-%m-%d-%H%M%S')"
          
          echo "�️ Building Docker image locally on self-hosted runner: $TAG"
          docker build \
            --platform linux/amd64 \
            --tag "$TAG" \
            --build-arg SERVICE_NAME="${{ env.SERVICE_NAME }}" \
            --build-arg BUILD_DATE="${{ github.event.head_commit.timestamp || github.run_id }}" \
            --build-arg VCS_REF="${{ github.sha }}" \
            --build-arg VERSION="1.0.0" \
            .
          
          echo "image_tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "✅ Image built locally on self-hosted runner (NO REGISTRY)"
      - name: � Deploy container directly
        timeout-minutes: 10
        run: |
          set -euo pipefail
          IMAGE_TAG="${{ steps.build.outputs.image_tag }}"
          CONTAINER_NAME="${{ env.SERVICE_NAME }}-microservice"
          
          # Criar nome do DB com sintaxe de shell pura
          DB_NAME_RAW="${{ env.SERVICE_NAME }}"
          DB_NAME="db_$(echo "$DB_NAME_RAW" | tr '-' '_')"
          export TZ=America/Sao_Paulo
          
          docker network create conexao-network 2>/dev/null || true
          
          echo "� Starting $CONTAINER_NAME container..."
          docker run -d \
            --name "$CONTAINER_NAME" \
            --network conexao-network \
            --restart unless-stopped \
            -p "8081:8080" \
            --health-cmd="curl -f http://localhost:8080/actuator/health/readiness && curl -f http://localhost:8080/actuator/health/liveness || exit 1" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-retries=5 \
            --health-start-period=60s \
            -e JAVA_TOOL_OPTIONS="-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0 -Xms256m -Xmx512m -Djava.security.egd=file:/dev/./urandom -Djava.awt.headless=true -Dfile.encoding=UTF-8" \
            -e SPRING_PROFILES_ACTIVE="prod,azure" \
            -e SERVER_PORT="8080" \
            -e TZ="America/Sao_Paulo" \
            -e AZURE_CLIENT_ID="${{ secrets.AZURE_CLIENT_ID }}" \
            -e AZURE_TENANT_ID="${{ secrets.AZURE_TENANT_ID }}" \
            -e AZURE_KEYVAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}" \
            -e AZURE_KEYVAULT_ENABLED="true" \
            -e SPRING_DATASOURCE_R2DBC_URL="r2dbc:mysql://${{ env.DB_HOST }}:${{ env.DB_PORT }}/$DB_NAME" \
            -e SPRING_DATASOURCE_R2DBC_USERNAME="${{ env.DB_USERNAME }}" \
            -e SPRING_DATASOURCE_R2DBC_PASSWORD="${{ env.DB_PASSWORD }}" \
            -e SPRING_FLYWAY_URL="jdbc:mysql://${{ env.DB_HOST }}:${{ env.DB_PORT }}/$DB_NAME" \
            -e SPRING_FLYWAY_USER="${{ env.DB_USERNAME }}" \
            -e SPRING_FLYWAY_PASSWORD="${{ env.DB_PASSWORD }}" \
            -e SPRING_REDIS_HOST="${{ env.REDIS_HOST }}" \
            -e SPRING_REDIS_PORT="${{ env.REDIS_PORT }}" \
            -e SPRING_REDIS_PASSWORD="${{ env.REDIS_PASSWORD }}" \
            -e SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI="${{ env.JWT_ISSUER }}" \
            -e SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_JWK_SET_URI="${{ env.JWT_JWKS_URI }}" \
            -e JWT_SIGNING_KEY="${{ env.JWT_SIGNING_KEY }}" \
            -e JWT_VERIFICATION_KEY="${{ env.JWT_VERIFICATION_KEY }}" \
            -e JWT_KEY_ID="${{ env.JWT_KEY_ID }}" \
            -e ENCRYPTION_MASTER_KEY="${{ env.ENCRYPTION_MASTER_KEY }}" \
            -e ENCRYPTION_BACKUP_KEY="${{ env.ENCRYPTION_BACKUP_KEY }}" \
            -e SSL_KEYSTORE_PASSWORD="${{ env.SSL_KEYSTORE_PASSWORD }}" \
            -e CORS_ALLOWED_ORIGINS="${{ env.CORS_ALLOWED_ORIGINS }}" \
            --label "traefik.enable=true" \
            --label "traefik.docker.network=conexao-network" \
            --label "traefik.http.routers.${{ env.SERVICE_NAME }}.rule=Host(\"${{ env.SERVICE_NAME }}.conexaodesorte.com.br\")" \
            --label "traefik.http.routers.${{ env.SERVICE_NAME }}.entrypoints=websecure" \
            --label "traefik.http.routers.${{ env.SERVICE_NAME }}.tls.certresolver=letsencrypt" \
            --label "traefik.http.services.${{ env.SERVICE_NAME }}.loadbalancer.server.port=8080" \
            "$IMAGE_TAG"
          
          echo "✅ Container deployed successfully"
      - name: Wait for service to be ready
        timeout-minutes: 10
        run: |
          CONTAINER_NAME="${{ env.SERVICE_NAME }}-microservice"
          echo "� Waiting for service to be ready..."
          TIMEOUT=180
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if docker exec $CONTAINER_NAME curl -f -s http://localhost:8080/actuator/health/readiness >/dev/null 2>&1; then
              echo "✅ Service is ready and healthy!"
              break
            fi
            echo "⏳ Waiting for service readiness... ($ELAPSED/$TIMEOUT seconds)"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "❌ Service failed to become ready within $TIMEOUT seconds"
            echo "� Container logs:"
            docker logs $CONTAINER_NAME --tail 50
            exit 1
          fi
          
          echo "� Final container status:"
          docker ps --filter name=$CONTAINER_NAME --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}'
          
          echo "� Self-hosted deployment completed successfully - Service is healthy!"
  notify:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    name: � Notification
    if: always()
    needs: [build-and-test, build-deploy-selfhosted]
    steps:
      - name: � Send Slack notification
        if: always()
        timeout-minutes: 10
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          DEPLOY_RESULT="${{ needs.build-deploy-selfhosted.result }}"
          if [ "$DEPLOY_RESULT" = "success" ]; then
            STATUS="� SUCCESS (Self-hosted)"
            COLOR="good"
          elif [ "$DEPLOY_RESULT" = "skipped" ]; then
            STATUS="⏭️ SKIPPED"
            COLOR="warning"
          else
            STATUS="❌ FAILED"
            COLOR="danger"
          fi
          if [ -n "${SLACK_WEBHOOK_URL:-}" ]; then
            curl -X POST -H 'Content-type: application/json' \
            --data "{'text':'$STATUS: Autenticacao Self-hosted Deploy','attachments':[{'color':'$COLOR','fields':[{'title':'Branch','value':'${{ github.ref_name }}','short':true},{'title':'Commit','value':'${{ github.sha }}','short':true},{'title':'Deploy Method','value':'Self-hosted Runner (No SSH)','short':true}]}]}" \
            $SLACK_WEBHOOK_URL || echo "Slack notification failed or webhook not configured"