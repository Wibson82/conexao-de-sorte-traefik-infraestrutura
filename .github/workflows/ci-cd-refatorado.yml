name: "üåê Traefik Infrastructure ‚Äì CI/CD Pipeline (Refatorado)"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      require_approval:
        description: 'Require manual approval for production'
        required: false
        default: true
        type: boolean

env:
  SERVICE_NAME: traefik-infrastructure

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4.3.0

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml

      - name: "[MIGRADO DE] scripts/validate-traefik.sh - Validate Traefik Configs"
        shell: bash
        run: |
          set -Eeuo pipefail
          IFS=$'\n\t'

          echo "üîç Validando artefatos e sintaxe do Traefik..."

          # Verificar se Python est√° dispon√≠vel para valida√ß√£o YAML
          if ! command -v python3 &> /dev/null; then
            echo "‚ö†Ô∏è Python3 n√£o encontrado, instalando..."
            # Em ambiente Ubuntu/Debian
            apt-get update && apt-get install -y python3 python3-yaml 2>/dev/null || true
          fi

          # Arquivos obrigat√≥rios
          required=(
            "docker-compose.yml"
            "traefik/traefik.yml"
            "traefik/dynamic/middlewares.yml"
            "traefik/dynamic/security-headers.yml"
            "traefik/dynamic/tls.yml"
          )

          for f in "${required[@]}"; do
            if [[ ! -f "$f" ]]; then
              echo "‚ùå Arquivo obrigat√≥rio n√£o encontrado: $f" >&2
              exit 1
            fi
            echo "‚úÖ $f encontrado"
          done

          echo "üîß Validando docker-compose.yml"

          # Criar uma vers√£o tempor√°ria do docker-compose.yml para valida√ß√£o
          # Remove networks externas para evitar erro de valida√ß√£o
          cp docker-compose.yml docker-compose-temp.yml

          # Substituir refer√™ncias a redes externas por redes padr√£o para valida√ß√£o
          sed -i 's/external: true/external: false/g' docker-compose-temp.yml 2>/dev/null || true

          # Validar sintaxe YAML sem verificar redes externas
          if docker compose -f docker-compose-temp.yml config --quiet >/dev/null 2>&1; then
            echo "‚úÖ Docker Compose sintaxe v√°lida"
          else
            echo "‚ö†Ô∏è Validando sintaxe YAML b√°sica..."
            # Fallback: validar apenas sintaxe YAML
            if command -v python3 &> /dev/null; then
              if python3 -c "import yaml; yaml.safe_load(open('docker-compose.yml'))" 2>/dev/null; then
                echo "‚úÖ Sintaxe YAML v√°lida"
              else
                echo "‚ùå Sintaxe YAML inv√°lida"
                rm -f docker-compose-temp.yml
                exit 1
              fi
            else
              # √öltimo recurso: valida√ß√£o b√°sica com comandos shell
              if grep -q "services:" docker-compose.yml && grep -q "image:" docker-compose.yml; then
                echo "‚úÖ Estrutura b√°sica do Docker Compose v√°lida"
              else
                echo "‚ùå Estrutura do Docker Compose inv√°lida"
                rm -f docker-compose-temp.yml
                exit 1
              fi
            fi
          fi

          # Limpar arquivo tempor√°rio
          rm -f docker-compose-temp.yml

          echo "‚úÖ Valida√ß√£o conclu√≠da"

      - name: "[MIGRADO DE] scripts/security-validation.sh - Security Validation"
        shell: bash
        run: |
          set -Eeuo pipefail
          IFS=$'\n\t'

          # =============================================================================
          # üîí TRAEFIK SECURITY VALIDATION SCRIPT
          # =============================================================================
          # Validates critical security configurations for Traefik infrastructure

          echo "üîí Iniciando valida√ß√£o de seguran√ßa do Traefik..."

          SCORE=0
          TOTAL=8
          CRITICAL_FAILURES=0

          # =============================================================================
          # Helper Functions
          # =============================================================================
          check_passed() {
              local description="$1"
              echo "‚úÖ $description"
              SCORE=$((SCORE + 1))
          }

          check_failed() {
              local description="$1"
              local is_critical="${2:-false}"
              echo "‚ùå $description"
              if [ "$is_critical" = "true" ]; then
                  CRITICAL_FAILURES=$((CRITICAL_FAILURES + 1))
              fi
          }

          check_warning() {
              local description="$1"
              echo "‚ö†Ô∏è  $description"
          }

          # =============================================================================
          # Security Checks
          # =============================================================================

          echo ""
          echo "üìã Executando verifica√ß√µes de seguran√ßa..."

          # 1. HTTPS Configuration
          echo ""
          echo "üîê [1/8] Verificando configura√ß√£o HTTPS..."
          if grep -q "websecure" traefik/traefik.yml && grep -q "443" traefik/traefik.yml; then
              check_passed "HTTPS configurado corretamente"
          else
              check_failed "HTTPS n√£o configurado adequadamente" true
          fi

          # 2. Let's Encrypt Configuration
          echo ""
          echo "üîê [2/8] Verificando Let's Encrypt..."
          if grep -q "letsencrypt" traefik/traefik.yml && grep -q "httpChallenge" traefik/traefik.yml; then
              check_passed "Let's Encrypt configurado"
          else
              check_failed "Let's Encrypt n√£o configurado" true
          fi

          # 3. Security Headers
          echo ""
          echo "üîê [3/8] Verificando Security Headers..."
          if [ -f "traefik/dynamic/security-headers.yml" ] && grep -q "Strict-Transport-Security" traefik/dynamic/security-headers.yml; then
              check_passed "Security Headers configurados"
          else
              check_failed "Security Headers inadequados" true
          fi

          # 4. Rate Limiting
          echo ""
          echo "üîê [4/8] Verificando Rate Limiting..."
          if [ -f "traefik/dynamic/middlewares.yml" ] && grep -q "rateLimit" traefik/dynamic/middlewares.yml; then
              check_passed "Rate Limiting configurado"
          else
              check_failed "Rate Limiting n√£o configurado"
          fi

          # 5. TLS Minimum Version
          echo ""
          echo "üîê [5/8] Verificando vers√£o m√≠nima TLS..."
          if [ -f "traefik/dynamic/tls.yml" ] && grep -q "VersionTLS12" traefik/dynamic/tls.yml; then
              check_passed "TLS vers√£o m√≠nima configurada (TLS 1.2+)"
          else
              check_failed "TLS vers√£o m√≠nima n√£o configurada"
          fi

          # 6. Access Logs
          echo ""
          echo "üîê [6/8] Verificando logs de acesso..."
          if grep -q "accessLog" traefik/traefik.yml; then
              check_passed "Logs de acesso habilitados"
          else
              check_failed "Logs de acesso n√£o habilitados"
          fi

          # 7. Dashboard Security
          echo ""
          echo "üîê [7/8] Verificando seguran√ßa do dashboard..."
          if grep -q "insecure.*false" traefik/traefik.yml || ! grep -q "insecure.*true" traefik/traefik.yml; then
              check_passed "Dashboard seguro (n√£o inseguro)"
          else
              check_failed "Dashboard inseguro detectado" true
          fi

          # 8. Container Healthcheck
          echo ""
          echo "üîê [8/8] Verificando healthcheck do container..."
          if grep -q "healthcheck" docker-compose.yml; then
              check_passed "Healthcheck configurado"
          else
              check_failed "Healthcheck n√£o configurado"
          fi

          # =============================================================================
          # Results Summary
          # =============================================================================
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üìä RESULTADO DA VALIDA√á√ÉO DE SEGURAN√áA"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

          PERCENTAGE=$(( SCORE * 100 / TOTAL ))
          echo "üéØ Score de Seguran√ßa: $SCORE/$TOTAL ($PERCENTAGE%)"

          if [ $CRITICAL_FAILURES -gt 0 ]; then
              echo "üö® FALHAS CR√çTICAS: $CRITICAL_FAILURES"
              echo ""
              echo "‚ùå DEPLOY BLOQUEADO: Corrija as falhas cr√≠ticas antes de prosseguir"
              exit 1
          elif [ $SCORE -lt 6 ]; then
              echo "‚ö†Ô∏è  Score de seguran√ßa baixo ($PERCENTAGE%)"
              echo ""
              echo "üî∂ DEPLOY COM ALERTA: Considere melhorar as configura√ß√µes de seguran√ßa"
              exit 2
          else
              echo "‚úÖ SEGURAN√áA APROVADA: Configura√ß√µes adequadas para produ√ß√£o"
              echo ""
              echo "üéâ Deploy autorizado com score de seguran√ßa: $PERCENTAGE%"
          fi

          echo ""
          echo "üí° Para melhorar o score de seguran√ßa:"
          echo "   - Configure todos os middlewares de seguran√ßa"
          echo "   - Habilite logs de acesso para auditoria"
          echo "   - Implemente rate limiting robusto"
          echo "   - Configure healthchecks adequados"
          echo ""

      - name: Create secrets directory for artifact
        run: |
          mkdir -p secrets
          # Criar arquivo b√°sico de auth se n√£o existir
          if [ ! -f secrets/traefik-basicauth ]; then
            echo 'admin:$2y$10$rQ.0eEWJx7mQ8k4yR4x9/.2l0JUqN7zYTHmFePXkz1YRkFvqRZ5hW' > secrets/traefik-basicauth
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4.5.0
        with:
          name: traefik-configs
          path: |
            docker-compose.yml
            .env.ci
            traefik/
            letsencrypt/
            secrets/

  approval-gate:
    needs: validate-and-build
    runs-on: ubuntu-latest
    timeout-minutes: 60
    if: github.ref == 'refs/heads/main' && (github.event.inputs.deploy_environment == 'production' || github.event.inputs.require_approval == 'true')
    steps:
      - name: "üîê Manual Approval Required for Production Deploy"
        run: |
          echo "üîí Aguardando aprova√ß√£o manual para deploy em produ√ß√£o..."
          echo "üìã Environment: ${{ github.event.inputs.deploy_environment || 'staging' }}"
          echo "üîç Ref: ${{ github.ref }}"
          echo "üë§ Actor: ${{ github.actor }}"
          echo "‚úÖ Deploy ser√° executado ap√≥s aprova√ß√£o manual"
          echo "‚è≥ Use 'workflow_dispatch' com 'require_approval: false' para pular esta etapa"

  deploy-selfhosted:
    needs: [validate-and-build, approval-gate]
    runs-on: [ self-hosted, Linux, X64, conexao, conexao-de-sorte-traefik-infraestrutura ]
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main' && (success() || needs.approval-gate.result == 'skipped')
    permissions:
      id-token: write
      contents: read
    env:
      DOCKER_NETWORK_NAME: conexao-network-swarm
      STACK_NAME: conexao-traefik
      COMPOSE_FILE: docker-compose.yml
    steps:
      - uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: Download artifacts
        uses: actions/download-artifact@v4.1.8
        with:
          name: traefik-configs
          path: .

      - name: "üîç Azure Login (OIDC) + Key Vault Secrets"
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Validate Key Vault Access
        shell: bash
        env:
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
        run: |
          set -Eeuo pipefail
          IFS=$'\n\t'

          echo "üîê Validando acesso ao Azure Key Vault..."

          # Verificar acesso ao Key Vault
          echo "::group::Key Vault Access Validation"
          if az keyvault secret list --vault-name "$AZURE_KEYVAULT_NAME" --output none 2>/dev/null; then
            echo "‚úÖ Acesso ao Key Vault verificado"
          else
            echo "‚ùå Falha no acesso ao Key Vault"
            exit 1
          fi
          echo "::endgroup::"

      - name: "[MIGRADO DE] scripts/create-docker-secrets.sh - Create Docker Secrets"
        shell: bash
        env:
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
        run: |
          set -Eeuo pipefail
          IFS=$'\n\t'

          echo "üîê Criando Docker Secrets a partir do Azure Key Vault..."

          # Fun√ß√£o para criar secret de forma segura
          create_docker_secret() {
            local secret_name="$1"
            local keyvault_secret="$2"

            echo "üîë Processando secret: $secret_name"

            # Verificar se secret j√° existe
            if docker secret ls --format "{{.Name}}" | grep -q "^${secret_name}$"; then
              echo "‚ÑπÔ∏è  Secret $secret_name j√° existe, removendo..."
              docker secret rm "$secret_name" 2>/dev/null || true
            fi

            # Recuperar valor do Key Vault (sem expor em logs)
            local secret_value
            secret_value=$(az keyvault secret show \
              --vault-name "$AZURE_KEYVAULT_NAME" \
              --name "$keyvault_secret" \
              --query "value" \
              --output tsv 2>/dev/null)

            if [ -n "$secret_value" ]; then
              # Criar Docker Secret
              echo "$secret_value" | docker secret create "$secret_name" - >/dev/null
              echo "‚úÖ Secret $secret_name criado com sucesso"
            else
              echo "‚ö†Ô∏è  Secret $keyvault_secret n√£o encontrado no Key Vault"
            fi
          }

          # Lista de secrets padronizados
          secrets_map=(
            "traefik-basicauth:TRAEFIK-BASICAUTH"
            "admin-users:ADMIN-USERS"
            "audit-users:AUDIT-USERS"
            "crypto-users:CRYPTO-USERS"
          )

          for mapping in "${secrets_map[@]}"; do
            docker_secret=$(echo "$mapping" | cut -d':' -f1)
            kv_secret=$(echo "$mapping" | cut -d':' -f2)
            create_docker_secret "$docker_secret" "$kv_secret"
          done

          echo "‚úÖ Todos os Docker Secrets foram criados"

      - name: "[MIGRADO DE] scripts/validate-secrets.sh - Validate Secrets"
        shell: bash
        run: |
          set -Eeuo pipefail
          IFS=$'\n\t'

          echo "üîç Validando Docker Secrets criados..."

          required_secrets=(
            "traefik-basicauth"
            "admin-users"
            "audit-users"
            "crypto-users"
          )

          validation_failed=false

          for secret in "${required_secrets[@]}"; do
            if docker secret ls --format "{{.Name}}" | grep -q "^${secret}$"; then
              echo "‚úÖ Secret $secret validado"
            else
              echo "‚ùå Secret $secret n√£o encontrado"
              validation_failed=true
            fi
          done

          if [ "$validation_failed" = "true" ]; then
            echo "‚ùå Valida√ß√£o de secrets falhou"
            exit 1
          fi

          echo "‚úÖ Todos os secrets validados com sucesso"

      - name: Prepare environment
        run: |
          # Usar arquivo de ambiente espec√≠fico para CI/CD
          cp .env.ci .env

      - name: "[MIGRADO DE] scripts/deploy-traefik.sh - Deploy Traefik Stack"
        shell: bash
        env:
          STACK_NAME: conexao-traefik
          COMPOSE_FILE: docker-compose.yml
        run: |
          set -Eeuo pipefail
          IFS=$'\n\t'

          # Deploy Traefik stack using Docker Swarm

          STACK_NAME=${STACK_NAME:-conexao-traefik}
          COMPOSE_FILE=${COMPOSE_FILE:-docker-compose.yml}

          echo "üîß Preparing environment for Traefik deploy..."

          # Check which network to use based on environment variable
          NETWORK_NAME=${DOCKER_NETWORK_NAME:-conexao-network-swarm}

          # OBRIGAT√ìRIO: Usar arquivo consolidado docker-compose.yml
          if [ -n "${COMPOSE_FILE:-}" ]; then
            echo "‚úÖ Usando arquivo especificado: $COMPOSE_FILE"
          else
            COMPOSE_FILE="docker-compose.yml"
            echo "üîÑ Usando arquivo consolidado: $COMPOSE_FILE"
          fi

          # Verificar se o arquivo obrigat√≥rio existe
          if [ ! -f "$COMPOSE_FILE" ]; then
            echo "‚ùå ERRO: Arquivo obrigat√≥rio n√£o encontrado: $COMPOSE_FILE"
            echo "üìã Arquivos dispon√≠veis:"
            ls -la docker-compose*.yml || true
            exit 1
          fi

          echo "üêù Usando Docker Swarm mode com $COMPOSE_FILE"

          # Ensure required network exists
          if [ "$NETWORK_NAME" = "conexao-network-swarm" ]; then
            echo "üåê Checking Docker Swarm overlay network: $NETWORK_NAME"
            if ! docker network ls --filter name="$NETWORK_NAME" --format "{{.Name}}" | grep -q "^$NETWORK_NAME$"; then
              echo "üåê Creating overlay network: $NETWORK_NAME"
              docker network create --driver overlay --attachable "$NETWORK_NAME" 2>/dev/null || true
            else
              echo "‚úÖ Network $NETWORK_NAME already exists"
            fi
          else
            echo "üåê Checking bridge network: $NETWORK_NAME"
            if ! docker network ls --filter name="$NETWORK_NAME" --format "{{.Name}}" | grep -q "^$NETWORK_NAME$"; then
              echo "üåê Creating bridge network: $NETWORK_NAME"
              docker network create "$NETWORK_NAME" 2>/dev/null || true
            else
              echo "‚úÖ Network $NETWORK_NAME already exists"
            fi
          fi

          # Ensure required directories exist
          echo "üìÅ Configurando diret√≥rios e arquivos necess√°rios..."
          echo "üìç Diret√≥rio de trabalho: $(pwd)"

          # Create directories
          echo "üóÇÔ∏è Criando diret√≥rios..."
          mkdir -p ./letsencrypt
          mkdir -p ./logs/traefik
          mkdir -p ./secrets
          echo "‚úÖ Todos os diret√≥rios criados"

          # Create acme.json with simpler approach
          echo "üîê Configurando arquivo acme.json..."
          echo '{}' > ./letsencrypt/acme.json
          chmod 600 ./letsencrypt/acme.json
          echo "‚úÖ Arquivo acme.json configurado com permiss√µes 600"

          # Create basic auth file for Traefik dashboard
          if [ ! -f ./secrets/traefik-basicauth ]; then
              echo "üîê Criando arquivo b√°sico de autentica√ß√£o..."
              echo 'admin:$2y$10$rQ.0eEWJx7mQ8k4yR4x9/.2l0JUqN7zYTHmFePXkz1YRkFvqRZ5hW' > ./secrets/traefik-basicauth
              chmod 600 ./secrets/traefik-basicauth
              echo "‚úÖ Arquivo traefik-basicauth criado"
          fi

          # Deploy the stack
          echo "üöÄ Deploying Traefik stack: $STACK_NAME using $COMPOSE_FILE"

          if docker stack deploy --compose-file "$COMPOSE_FILE" "$STACK_NAME"; then
              echo "‚úÖ Stack $STACK_NAME deployed successfully!"
          else
              echo "‚ùå Failed to deploy stack $STACK_NAME"
              exit 1
          fi

          # Wait for services to be ready with proper checks
          echo "‚è≥ Aguardando servi√ßos ficarem prontos..."
          echo "üìã Aguardando 30 segundos para estabiliza√ß√£o inicial..."
          sleep 30

          # Wait for service to be created and running
          echo "üîç Aguardando servi√ßo ser criado..."
          for i in {1..30}; do
              if docker service ls --filter name="${STACK_NAME}_traefik" --format "{{.Name}}" | grep -q traefik; then
                  echo "‚úÖ Servi√ßo ${STACK_NAME}_traefik criado ($i/30)"
                  break
              fi
              echo "‚è≥ Aguardando servi√ßo... ($i/30)"
              sleep 2
          done

          # Wait for at least one replica to be running
          echo "üîç Aguardando r√©plicas ficarem ativas..."
          for i in {1..60}; do
              REPLICAS=$(docker service ls --filter name="${STACK_NAME}_traefik" --format "{{.Replicas}}" | head -1)
              echo "üìä Status atual: $REPLICAS ($i/60)"

              if [[ "$REPLICAS" == "1/1" ]]; then
                  echo "‚úÖ Todas as r√©plicas est√£o ativas!"
                  break
              elif [[ "$REPLICAS" == "0/1" ]]; then
                  echo "‚ö†Ô∏è  Container ainda inicializando..."
              fi

              sleep 5
          done

          # Verify deployment
          echo "üîç Verificando status final do deployment..."
          docker stack ps "$STACK_NAME" --no-trunc

          echo "üåê Verificando servi√ßos do stack..."
          docker stack services "$STACK_NAME"

          echo "‚úÖ Deploy do Traefik finalizado com sucesso!"
          echo "üåê Traefik Dashboard: https://traefik.conexaodesorte.com.br"
          echo "üîê API: https://api.conexaodesorte.com.br"
          echo ""
          echo "‚ÑπÔ∏è  IMPORTANTE: Container pode levar alguns minutos adicionais para estar totalmente funcional"
          echo "üîß Pr√≥ximos scripts ir√£o validar conectividade HTTP quando container estiver pronto"

      - name: "[MIGRADO DE] scripts/healthcheck-traefik.sh - Healthcheck Traefik"
        shell: bash
        env:
          STACK_NAME: conexao-traefik
        run: |
          set -Eeuo pipefail
          IFS=$'\n\t'

          STACK=${STACK_NAME:-conexao-traefik}

          echo "üîç Validando sa√∫de do servi√ßo ${STACK}_traefik..."

          replicas=$(docker service ls --filter name="${STACK}_traefik" --format "{{.Replicas}}" | head -1 || true)
          if [[ -z "$replicas" ]]; then
            echo "‚ùå Servi√ßo ${STACK}_traefik n√£o encontrado" >&2
            docker service ls | grep "$STACK" || true
            exit 1
          fi

          echo "‚ÑπÔ∏è  R√©plicas atuais: $replicas"

          echo "üîé √öltimos logs do servi√ßo:"
          docker service logs "${STACK}_traefik" --tail 80 || true

          echo "‚úÖ Healthcheck conclu√≠do"

      - name: "[MIGRADO DE] scripts/connectivity-validation.sh - Connectivity Validation"
        shell: bash
        env:
          STACK_NAME: conexao-traefik
        run: |
          set -Eeuo pipefail
          IFS=$'\n\t'

          echo "üåê Validando conectividade HTTP/HTTPS..."

          # URLs para teste (ajustar conforme necess√°rio)
          TEST_URLS=(
            "http://localhost:80"
            "http://localhost:8080"
          )

          validation_failed=false

          for url in "${TEST_URLS[@]}"; do
            echo "üîó Testando conectividade: $url"

            if curl -s -f -m 10 "$url" >/dev/null 2>&1; then
              echo "‚úÖ $url - Conectividade OK"
            else
              # Toler√¢ncia para servi√ßos que podem estar inicializando
              echo "‚ö†Ô∏è  $url - Conectividade falhou (pode estar inicializando)"
              sleep 5

              # Segunda tentativa
              if curl -s -f -m 10 "$url" >/dev/null 2>&1; then
                echo "‚úÖ $url - Conectividade OK (segunda tentativa)"
              else
                echo "‚ùå $url - Conectividade falhou definitivamente"
                validation_failed=true
              fi
            fi
          done

          if [ "$validation_failed" = "true" ]; then
            echo "‚ö†Ô∏è  Algumas valida√ß√µes de conectividade falharam"
            echo "‚ÑπÔ∏è  Isso pode ser normal durante a inicializa√ß√£o dos servi√ßos"
            # N√£o falhar o pipeline para permitir que servi√ßos terminem de inicializar
          else
            echo "‚úÖ Todas as valida√ß√µes de conectividade passaram"
          fi

          echo "‚úÖ Valida√ß√£o de conectividade conclu√≠da"

  post-deploy-monitoring:
    needs: deploy-selfhosted
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: always() && needs.deploy-selfhosted.result != 'skipped'
    steps:
      - name: "üìä Post-Deploy Monitoring & Rollback Check"
        run: |
          echo "üìä Iniciando monitoramento p√≥s-deploy..."
          echo "üîç Deploy Status: ${{ needs.deploy-selfhosted.result }}"
          echo "‚è∞ Deploy Time: $(date -u)"

          if [ "${{ needs.deploy-selfhosted.result }}" = "success" ]; then
            echo "‚úÖ Deploy executado com sucesso"
            echo "üìã Pr√≥ximos passos:"
            echo "  - Monitorar logs do Traefik"
            echo "  - Verificar certificados SSL"
            echo "  - Testar conectividade dos servi√ßos"
            echo "  - Validar health checks"
          else
            echo "‚ùå Deploy falhou - rollback pode ser necess√°rio"
            echo "üîÑ Para rollback manual:"
            echo "  1. Conectar ao servidor self-hosted"
            echo "  2. Executar: docker stack rm conexao-traefik"
            echo "  3. Restaurar vers√£o anterior"
            echo "  4. Investigar logs de erro"
          fi

          echo "üìñ Documenta√ß√£o dispon√≠vel:"
          echo "  - RELATORIO-VALIDACAO.md"
          echo "  - LIMPEZA-EXECUTADA.md"
          echo "  - README.md (instru√ß√µes atualizadas)"