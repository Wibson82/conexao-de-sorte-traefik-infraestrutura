name: "🚀 Traefik Infrastructure – CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# Controle de concorrência para evitar execuções simultâneas
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Variáveis de ambiente global
env:
  SERVICE_NAME: traefik-infrastructure
  STACK_NAME: conexao-traefik
  DOCKER_NETWORK_NAME: conexao-network-swarm

permissions:
  id-token: write    # Necessário para OIDC com Azure (azure/login@v2)
  contents: read     # Necessário para checkout em jobs

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml jq

      - name: Validate Docker Compose
        run: |
          docker compose -f docker-compose.yml config -q
          echo "✅ Docker Compose syntax is valid"

      - name: Security Validation - No Hardcoded Passwords
        run: |
          # Verificar se não há hardcoded passwords
          if grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "external:"; then
            echo "❌ Found potential hardcoded passwords"
            exit 1
          else
            echo "✅ No hardcoded passwords found"
          fi

      - name: Validate Required Variables
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
        run: |
          required_vars=(
            "AZURE_CLIENT_ID"
            "AZURE_TENANT_ID"
            "AZURE_SUBSCRIPTION_ID"
            "AZURE_KEYVAULT_NAME"
          )

          missing=()
          for var in "${required_vars[@]}"; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done

          if [[ ${#missing[@]} -gt 0 ]]; then
            printf '❌ GitHub Variables obrigatórios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi

          echo "✅ All required variables are present"

      - name: Validate YAML files
        run: |
          python3 -c "
          import yaml
          import pathlib

          # Validar arquivos YAML principais
          yaml_files = [
              'docker-compose.yml',
              'traefik/traefik.yml'
          ]

          for file_path in yaml_files:
              if pathlib.Path(file_path).exists():
                  try:
                      with open(file_path, 'r', encoding='utf-8') as f:
                          yaml.safe_load(f)
                      print(f'✅ YAML válido: {file_path}')
                  except Exception as e:
                      print(f'❌ Erro no YAML {file_path}: {e}')
                      exit(1)
          "

      - name: Cache optimization setup
        run: |
          # Configurar ambiente de cache inteligente
          CACHE_DIR="/tmp/.traefik-cache"
          mkdir -p "$CACHE_DIR"/{configs,secrets,compose}

          # Gerar chaves de cache baseadas em hash dos arquivos
          CONFIG_HASH=$(find traefik/ -name "*.yml" -o -name "*.yaml" | sort | xargs sha256sum | sha256sum | cut -d' ' -f1 | head -c 12)
          COMPOSE_HASH=$(sha256sum docker-compose.yml | cut -d' ' -f1 | head -c 12)

          echo "CONFIG_CACHE_KEY=traefik-config-${CONFIG_HASH}" >> $GITHUB_ENV
          echo "COMPOSE_CACHE_KEY=traefik-compose-${COMPOSE_HASH}" >> $GITHUB_ENV
          echo "CACHE_DIR=$CACHE_DIR" >> $GITHUB_ENV

          echo "✅ Cache optimization configurado"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4.5.0
        with:
          name: traefik-configs
          path: |
            docker-compose.yml
            traefik/
          retention-days: 1

  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [self-hosted, Linux, X64, conexao, conexao-de-sorte-traefik-infraestrutura]
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: Download artifacts
        uses: actions/download-artifact@v4.1.8
        with:
          name: traefik-configs
          path: .

      - name: Azure Login (OIDC) with Security Hardening
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          audience: api://AzureADTokenExchange
          allow-no-subscriptions: false

      - name: Get Key Vault secrets (Infra Domain Only)
        id: kv
        shell: bash
        env:
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
        run: |
          set -Eeuo pipefail
          IFS=$'\n\t'

          echo "🔐 Recuperando segredos do Key Vault (infra-only)..."

          # Buscar apenas segredos essenciais para o Traefik
          declare -A essential_mapping=(
            [ACME_EMAIL]=conexao-de-sorte-letsencrypt-email
            [DASHBOARD_SECRET]=conexao-de-sorte-traefik-dashboard-password
          )

          # Buscar segredos opcionais (não críticos)
          declare -A optional_mapping=(
            [SSL_CERT_PASSWORD]=conexao-de-sorte-ssl-cert-password
            [TRAEFIK_BASICAUTH]=conexao-de-sorte-traefik-basicauth-password
          )

          essential_missing=()
          optional_missing=()

          # Processar segredos essenciais
          for var in "${!essential_mapping[@]}"; do
            secret_name=${essential_mapping[$var]}
            secret_value=$(az keyvault secret show --vault-name "$AZURE_KEYVAULT_NAME" --name "$secret_name" --query value -o tsv 2>/dev/null || true)
            if [[ -n "$secret_value" ]]; then
              echo "::add-mask::$secret_value"
              echo "$var=$secret_value" >> "$GITHUB_ENV"
              echo "✅ Recuperado e mascarado: $secret_name -> $var"
            else
              essential_missing+=("$secret_name")
            fi
          done

          # Processar segredos opcionais
          for var in "${!optional_mapping[@]}"; do
            secret_name=${optional_mapping[$var]}
            secret_value=$(az keyvault secret show --vault-name "$AZURE_KEYVAULT_NAME" --name "$secret_name" --query value -o tsv 2>/dev/null || true)
            if [[ -n "$secret_value" ]]; then
              echo "::add-mask::$secret_value"
              echo "$var=$secret_value" >> "$GITHUB_ENV"
              echo "✅ Recuperado e mascarado: $secret_name -> $var"
            else
              optional_missing+=("$secret_name")
              echo "⚠️ Segredo opcional não encontrado: $secret_name"
            fi
          done

          # Validar se segredos essenciais foram encontrados
          if [[ ${#essential_missing[@]} -gt 0 ]]; then
            echo "❌ Segredos essenciais ausentes: ${essential_missing[*]}"
            exit 1
          fi

          echo "✅ Todos os segredos essenciais foram recuperados"

      - name: Prepare secrets and configuration
        env:
          ACME_EMAIL: ${{ env.ACME_EMAIL }}
          DASHBOARD_SECRET: ${{ env.DASHBOARD_SECRET }}
          SSL_CERT_PASSWORD: ${{ env.SSL_CERT_PASSWORD }}
          TRAEFIK_BASICAUTH: ${{ env.TRAEFIK_BASICAUTH }}
        run: |
          set -Eeuo pipefail

          # Validar segredos essenciais
          if [[ -z "$DASHBOARD_SECRET" || -z "$ACME_EMAIL" ]]; then
            echo '❌ Segredos essenciais não retornados pelo Key Vault'
            echo "DASHBOARD_SECRET: $([ -n "$DASHBOARD_SECRET" ] && echo "✅ Presente" || echo "❌ Ausente")"
            echo "ACME_EMAIL: $([ -n "$ACME_EMAIL" ] && echo "✅ Presente" || echo "❌ Ausente")"
            exit 1
          fi

          echo "::add-mask::$DASHBOARD_SECRET"
          echo "::add-mask::$ACME_EMAIL"

          # Mascarar segredos opcionais se presentes
          [[ -n "${SSL_CERT_PASSWORD:-}" ]] && echo "::add-mask::$SSL_CERT_PASSWORD"
          [[ -n "${TRAEFIK_BASICAUTH:-}" ]] && echo "::add-mask::$TRAEFIK_BASICAUTH"

          mkdir -p secrets letsencrypt

          # Criar arquivo de basic auth apenas com o segredo essencial
          printf '%s\n' "$DASHBOARD_SECRET" > secrets/traefik-basicauth
          chmod 600 secrets/traefik-basicauth

          # Adicionar auth opcional se disponível
          if [[ -n "${TRAEFIK_BASICAUTH:-}" ]]; then
            printf '%s\n' "$TRAEFIK_BASICAUTH" > secrets/traefik-optional-auth
            chmod 600 secrets/traefik-optional-auth
            echo "✅ Auth opcional adicionado"
          fi

          if [[ ! -f letsencrypt/acme.json ]]; then
            printf '{}\n' > letsencrypt/acme.json
          fi
          chmod 600 letsencrypt/acme.json

          cp .env.ci .env
          python3 -c "
          import os
          import pathlib

          acme_email = os.environ['ACME_EMAIL']
          env_path = pathlib.Path('.env')

          if env_path.exists():
              lines = env_path.read_text(encoding='utf-8').splitlines()
              seen_acme = False
              seen_staging = False
              with env_path.open('w', encoding='utf-8') as handle:
                  for line in lines:
                      if line.startswith('TRAEFIK_ACME_EMAIL='):
                          handle.write(f'TRAEFIK_ACME_EMAIL={acme_email}\n')
                          seen_acme = True
                      elif line.startswith('LETSENCRYPT_STAGING='):
                          handle.write('LETSENCRYPT_STAGING=false\n')
                          seen_staging = True
                      else:
                          handle.write(line + '\n')
                  if not seen_acme:
                      handle.write(f'TRAEFIK_ACME_EMAIL={acme_email}\n')
                  if not seen_staging:
                      handle.write('LETSENCRYPT_STAGING=false\n')
          "

          echo "✅ Configuração de segredos concluída"

      - name: Ensure Docker network
        run: |
          set -Eeuo pipefail
          if ! docker network ls | grep -q "$DOCKER_NETWORK_NAME"; then
            echo "🌐 Criando rede $DOCKER_NETWORK_NAME"
            docker network create --driver overlay "$DOCKER_NETWORK_NAME"
          else
            echo "✅ Rede $DOCKER_NETWORK_NAME já existe"
          fi

      - name: Deploy Traefik stack
        run: |
          set -Eeuo pipefail
          docker compose -f docker-compose.yml config -q
          docker stack deploy -c docker-compose.yml "$STACK_NAME"
          echo "⏳ Aguardando estabilização do Traefik..."
          sleep 30

      - name: Health check (Traefik)
        run: |
          set -Eeuo pipefail
          service="${STACK_NAME}_traefik"
          attempts=12
          for attempt in $(seq 1 "$attempts"); do
            echo "🔍 Tentativa $attempt/$attempts - Verificando Traefik"
            container=$(docker ps --filter "name=${service}" -q | head -n1)
            if [[ -n "$container" ]]; then
              # Health check específico para Traefik
              if docker exec "$container" wget -q -O- http://localhost:8080/ping 2>/dev/null | grep -q "OK"; then
                echo "✅ Traefik respondendo corretamente"
                exit 0
              fi
            fi
            sleep 10
          done

          echo "❌ Health check do Traefik falhou"
          docker service ps "$service" || true
          docker service logs "$service" --tail 50 || true
          exit 1

      - name: Post-deploy summary
        run: |
          set -Eeuo pipefail
          echo "📊 Resumo do deploy:"
          docker service ls | grep -E "(traefik|NAME)" || true
          docker network ls | grep -E "(conexao|NAME)" || true
          echo "✅ Deploy do Traefik Infrastructure concluído"

  cleanup-artifacts:
    needs: deploy-selfhosted
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: always()
    permissions:
      contents: read
    steps:
      - name: Cleanup artifacts
        run: |
          echo "🧹 Limpando artefatos antigos..."
          # Aqui poderia ser implementada limpeza de artefatos via API do GitHub
          echo "✅ Limpeza de artefatos concluída"
