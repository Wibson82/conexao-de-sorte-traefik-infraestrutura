name: "üöÄ Traefik Infrastructure - CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# Controle de concorr√™ncia para evitar execu√ß√µes simult√¢neas
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Vari√°veis de ambiente global
env:
  SERVICE_NAME: traefik-infrastructure
  STACK_NAME: conexao-traefik
  DOCKER_NETWORK_NAME: conexao-network-swarm

permissions:
  id-token: write    # Necess√°rio para OIDC com Azure (azure/login@v2)
  contents: read     # Necess√°rio para checkout em jobs

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      id-token: write
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml jq

      - name: Validate Docker Compose
        run: |
          docker compose -f docker-compose.yml config -q
          echo "‚úÖ Docker Compose syntax is valid"

      - name: Security Validation - No Hardcoded Passwords
        run: |
          # Verificar se n√£o h√° hardcoded passwords
          if grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "external:"; then
            echo "‚ùå Found potential hardcoded passwords"
            exit 1
          else
            echo "‚úÖ No hardcoded passwords found"
          fi

      - name: üîé Validar OIDC Azure
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
          AZURE_KEYVAULT_ENDPOINT: ${{ secrets.AZURE_KEYVAULT_ENDPOINT }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf '‚ùå GitHub Secrets obrigat√≥rios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "‚úÖ Identificadores Azure configurados via secrets"
          
          # Key Vault √© opcional
          if [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_keyvault=false" >> "$GITHUB_OUTPUT"
          fi
          
          if [[ -z "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            echo '‚ÑπÔ∏è AZURE_KEYVAULT_ENDPOINT n√£o definido (usando endpoint padr√£o)'
          else
            echo '‚úÖ Endpoint customizado definido'
          fi
          
          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"

      - name: Validate YAML files
        run: |
          python3 -c "
          import yaml
          import pathlib

          # Validar arquivos YAML principais
          yaml_files = [
              'docker-compose.yml',
              'traefik/traefik.yml'
          ]

          for file_path in yaml_files:
              if pathlib.Path(file_path).exists():
                  try:
                      with open(file_path, 'r', encoding='utf-8') as f:
                          yaml.safe_load(f)
                      print(f'‚úÖ YAML v√°lido: {file_path}')
                  except Exception as e:
                      print(f'‚ùå Erro no YAML {file_path}: {e}')
                      exit(1)
          "

      - name: Cache optimization setup
        run: |
          # Configurar ambiente de cache inteligente
          CACHE_DIR="/tmp/.traefik-cache"
          mkdir -p "$CACHE_DIR"/{configs,secrets,compose}

          # Gerar chaves de cache baseadas em hash dos arquivos
          CONFIG_HASH=$(find traefik/ -name "*.yml" -o -name "*.yaml" | sort | xargs sha256sum | sha256sum | cut -d' ' -f1 | head -c 12)
          COMPOSE_HASH=$(sha256sum docker-compose.yml | cut -d' ' -f1 | head -c 12)

          echo "CONFIG_CACHE_KEY=traefik-config-${CONFIG_HASH}" >> $GITHUB_ENV
          echo "COMPOSE_CACHE_KEY=traefik-compose-${COMPOSE_HASH}" >> $GITHUB_ENV
          echo "CACHE_DIR=$CACHE_DIR" >> $GITHUB_ENV

          echo "‚úÖ Cache optimization configurado"

      - name: ‚úÖ Confirmar consumo m√≠nimo do Key Vault
        if: ${{ steps.check_secrets.outputs.has_keyvault == 'true' }}
        run: |
          echo 'Job de valida√ß√£o n√£o consome segredos do Key Vault (lista vazia).'
          echo "‚úÖ Valida√ß√£o de Key Vault conclu√≠da sem consumo de segredos"
          
      - name: Validation completed
        run: |
          echo "‚úÖ Valida√ß√£o conclu√≠da - pronto para deploy"

  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [self-hosted, Linux, X64, conexao-de-sorte-traefik-infraestrutura]
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: üîê Azure Login (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: üîí Security Validation - Port Exposure
        run: |
          # Verificar exposi√ß√£o de portas do Traefik
          if grep -E "^\s*-\s*[\"']?(80|443|8080):" docker-compose.yml; then
            echo "‚ö†Ô∏è WARNING: Traefik ports may be exposed - ensure firewall protection"
            echo "üîí Note: Current configuration works but consider overlay-only for maximum security"
          else
            echo "‚úÖ No ports exposed - maximum security (overlay network only)"
          fi

      - name: üîê Get secrets from Azure Key Vault (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        run: |
          # Usar endpoint se dispon√≠vel, sen√£o usar nome com fallback
          KEYVAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          if [[ -n "$KEYVAULT_ENDPOINT" ]]; then
            KEYVAULT_NAME=$(echo "$KEYVAULT_ENDPOINT" | sed 's|https://\(.*\)\.vault\.azure\.net/.*|\1|')
            echo "üìç Usando Key Vault do endpoint: $KEYVAULT_NAME"
          else
            KEYVAULT_NAME="${{ secrets.AZURE_KEYVAULT_NAME || 'kv-conexao-de-sorte' }}"
            echo "üìç Usando Key Vault do nome: $KEYVAULT_NAME"
          fi

          # Obter secrets essenciais
          secrets_list="conexao-de-sorte-letsencrypt-email,conexao-de-sorte-traefik-dashboard-password"

          IFS=',' read -ra SECRETS_ARRAY <<< "$secrets_list"
          for secret_name in "${SECRETS_ARRAY[@]}"; do
            echo "üîç Obtendo segredo: $secret_name"
            secret_value=$(az keyvault secret show --vault-name "$KEYVAULT_NAME" --name "$secret_name" --query 'value' -o tsv 2>/dev/null || echo "")

            if [[ -n "$secret_value" ]]; then
              echo "‚úÖ Segredo obtido: $secret_name"
              echo "$secret_name=$secret_value" >> $GITHUB_ENV
            else
              echo "‚ùå Erro ao obter segredo: $secret_name"
              exit 1
            fi
          done

      - name: ‚úÖ Validar secrets essenciais obtidos via OIDC
        run: |
          echo "üîç Validando segredos essenciais obtidos via OIDC..."

          missing=()
          if [[ -z "${conexao-de-sorte-letsencrypt-email:-}" ]]; then
            missing+=("conexao-de-sorte-letsencrypt-email")
          fi
          if [[ -z "${conexao-de-sorte-traefik-dashboard-password:-}" ]]; then
            missing+=("conexao-de-sorte-traefik-dashboard-password")
          fi

          if [[ ${#missing[@]} -gt 0 ]]; then
            echo "‚ùå Segredos essenciais n√£o obtidos via OIDC:"
            printf '   - %s\n' "${missing[@]}"
            echo "üí° Verifique se o Key Vault est√° acess√≠vel e os segredos existem"
            exit 1
          fi

          echo "‚úÖ Todos os segredos essenciais foram obtidos com sucesso via OIDC"

      - name: üöÄ Deploy Traefik Stack (OIDC)
        env:
          STACK_NAME: conexao-traefik
          COMPOSE_FILE: docker-compose.yml
          DOCKER_NETWORK_NAME: conexao-network-swarm
        run: |
          echo "üöÄ Iniciando deploy do Traefik com Docker Swarm..."

          # Configurar vari√°veis com valores dos segredos (docker-compose.yml compatible)
          TRAEFIK_ACME_EMAIL="${conexao-de-sorte-letsencrypt-email}"
          DASHBOARD_PASSWORD="${conexao-de-sorte-traefik-dashboard-password}"

          if [[ -z "$TRAEFIK_ACME_EMAIL" ]]; then
            echo "‚ùå Email Let's Encrypt n√£o configurado - deploy cancelado"
            exit 1
          fi

          if [[ -z "$DASHBOARD_PASSWORD" ]]; then
            echo "‚ùå Senha do dashboard n√£o configurada - deploy cancelado"
            exit 1
          fi

          # Exportar vari√°veis para o ambiente (nomes corretos para docker-compose.yml)
          export TRAEFIK_ACME_EMAIL
          export DASHBOARD_PASSWORD

          # üîç DEBUG: Verificar arquivos necess√°rios para Traefik
          echo "üîç Verificando arquivos necess√°rios para Traefik..."
          for required_file in "traefik/traefik.yml" "docker-compose.yml"; do
            if [[ -f "$required_file" ]]; then
              echo "‚úÖ $required_file encontrado"
            else
              echo "‚ùå $required_file N√ÉO encontrado"
            fi
          done

          # üîç DEBUG: Verificar diret√≥rios necess√°rios
          for required_dir in "traefik" "traefik/dynamic" "letsencrypt" "secrets"; do
            if [[ -d "$required_dir" ]]; then
              echo "‚úÖ Diret√≥rio $required_dir existe"
            else
              echo "‚ö†Ô∏è Diret√≥rio $required_dir n√£o existe - criando..."
              mkdir -p "$required_dir"
            fi
          done

          # Criar rede se n√£o existir
          if ! docker network ls | grep -q "conexao-network-swarm"; then
            echo "üåê Criando rede conexao-network-swarm"
            docker network create --driver overlay conexao-network-swarm
          else
            echo "‚úÖ Rede conexao-network-swarm j√° existe"
          fi

          # üîê Criar Docker Secret para basicauth dinamicamente
          echo "üîê Criando Docker Secret para Traefik basicauth..."
          SECRET_NAME="traefik_basicauth_secret"

          # Verificar se secret j√° existe (n√£o tentar remover se em uso)
          if docker secret ls --format "{{.Name}}" | grep -q "^$SECRET_NAME$"; then
            echo "‚úÖ Docker Secret '$SECRET_NAME' j√° existe - reutilizando"
          else
            echo "üîê Criando novo Docker Secret para Traefik basicauth..."

            # Gerar hash da senha do dashboard para basicauth usando Python
            echo "üîê Gerando hash MD5 usando Python..."
            BASICAUTH_HASH=$(python3 -c "
            import hashlib
            password = '$DASHBOARD_PASSWORD'
            # Usar MD5 para compatibilidade (evitar warnings crypt deprecated)
            hash_pwd = hashlib.md5(password.encode()).hexdigest()
            print(f'admin:\$1\$salt\${hash_pwd}')
            ")

            if [[ -z "$BASICAUTH_HASH" ]]; then
              echo "‚ùå Erro ao gerar hash basicauth"
              exit 1
            fi

            # Criar novo secret
            echo "$BASICAUTH_HASH" | docker secret create "$SECRET_NAME" -
            echo "‚úÖ Docker Secret '$SECRET_NAME' criado com sucesso"
          fi

          # Remover stack existente se houver
          if docker stack ls | grep -q "$STACK_NAME"; then
            echo "üîÑ Removendo stack existente '$STACK_NAME'..."
            docker stack rm "$STACK_NAME"

            echo "‚è∞ Aguardando remo√ß√£o completa do stack..."
            # Aguardar at√© que todos os servi√ßos sejam removidos
            timeout=60
            elapsed=0
            while [ $elapsed -lt $timeout ] && docker service ls --filter label=com.docker.stack.namespace="$STACK_NAME" --quiet | grep -q .; do
              echo "‚è≥ Aguardando remo√ß√£o dos servi√ßos... ($elapsed/$timeout segundos)"
              sleep 5
              elapsed=$((elapsed + 5))
            done

            # Tentar remover configs √≥rf√£os se existirem
            echo "üîß Limpando configs √≥rf√£os..."
            for config_name in "${STACK_NAME}_traefik_config" "${STACK_NAME}_health_endpoints_config"; do
              if docker config ls --format "{{.Name}}" | grep -q "^$config_name$"; then
                echo "üîÑ Removendo config √≥rf√£o: $config_name"
                docker config rm "$config_name" 2>/dev/null || echo "‚ÑπÔ∏è Config $config_name ainda em uso ou n√£o existe"
              fi
            done

            echo "‚úÖ Stack removido completamente"
          fi

          # Deploy da nova stack
          echo "üèóÔ∏è Executando deploy da stack '$STACK_NAME'..."
          docker stack deploy -c "$COMPOSE_FILE" "$STACK_NAME"

          echo "‚è∞ Aguardando estabiliza√ß√£o dos servi√ßos Traefik..."
          sleep 15

          # üîç DEBUG: Verificar status do servi√ßo imediatamente ap√≥s deploy
          echo "üîç DEBUG: Status do servi√ßo Traefik ap√≥s deploy..."
          docker service ls --filter name="${STACK_NAME}_traefik" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}\t{{.Mode}}"

          echo "üîç DEBUG: Tasks do servi√ßo Traefik..."
          docker service ps "${STACK_NAME}_traefik" --no-trunc || echo "Servi√ßo ainda n√£o existe"

          sleep 20


      - name: Healthcheck Traefik (Multi-m√©todo)
        env:
          STACK_NAME: conexao-traefik
        run: |
          echo "üîç Validando sa√∫de do Traefik com health checks robustos..."

          # Aguardar at√© 3 minutos para Traefik ficar dispon√≠vel
          timeout=180
          elapsed=0
          health_passed=false

          while [ $elapsed -lt $timeout ] && [ "$health_passed" = false ]; do
            TRAEFIK_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_traefik" | head -1)

            if [ -n "$TRAEFIK_CONTAINER" ]; then
              echo "üîç Testando health check do Traefik... ($elapsed/$timeout segundos)"

              # M√©todo 1: Comando nativo wget para ping endpoint
              if docker exec "$TRAEFIK_CONTAINER" wget -q -O- http://localhost:8080/ping 2>/dev/null | grep -q "OK"; then
                echo "‚úÖ Traefik health check passed (ping endpoint)"
                health_passed=true
                break
              fi

              # M√©todo 2: Verificar logs de inicializa√ß√£o
              if docker logs "$TRAEFIK_CONTAINER" 2>/dev/null | grep -q "Configuration loaded\\|Traefik version"; then
                echo "‚úÖ Traefik health check passed (logs validation)"
                health_passed=true
                break
              fi

              # M√©todo 3: Verificar se porta est√° ativa
              if docker exec "$TRAEFIK_CONTAINER" ss -tuln 2>/dev/null | grep -q ":8080\\|:80\\|:443"; then
                echo "‚úÖ Traefik health check passed (ports active)"
                health_passed=true
                break
              fi

              echo "‚è≥ Traefik ainda n√£o est√° pronto... ($elapsed/$timeout segundos)"
            else
              echo "‚è≥ Container Traefik ainda n√£o encontrado... ($elapsed/$timeout segundos)"
            fi

            sleep 10
            elapsed=$((elapsed + 10))
          done

          if [ "$health_passed" = false ]; then
            echo "‚ö†Ô∏è Traefik health check n√£o passou em $timeout segundos"
            echo "üîç Verificando logs finais do Traefik..."
            if [ -n "$TRAEFIK_CONTAINER" ]; then
              echo "--- √öltimos 30 logs do Traefik ---"
              docker logs "$TRAEFIK_CONTAINER" --tail 30 2>/dev/null || true
              echo "--- Fim dos logs ---"
            fi
            echo "üí° Nota: Traefik pode estar funcionando mesmo com health check parcial"
            echo "üí° Verifique os logs acima para diagn√≥stico"
            exit 1
          else
            echo "‚úÖ Traefik health check conclu√≠do com sucesso!"
          fi

      - name: Connectivity Validation
        env:
          STACK_NAME: conexao-traefik
        run: |
          echo "üîç Validando conectividade do Traefik..."

          # Verificar se o servi√ßo est√° listado no Swarm
          if docker service ls | grep -q "${STACK_NAME}_traefik"; then
            echo "‚úÖ Servi√ßo Traefik encontrado no Swarm"
          else
            echo "‚ùå Servi√ßo Traefik n√£o encontrado no Swarm"
            exit 1
          fi

          # Verificar se est√° na rede correta
          if docker network inspect conexao-network-swarm | grep -q traefik; then
            echo "‚úÖ Traefik conectado √† rede overlay"
          else
            echo "‚ö†Ô∏è Traefik pode n√£o estar na rede overlay correta"
          fi

          # Verificar endpoints espec√≠ficos
          TRAEFIK_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_traefik" | head -1)
          if [ -n "$TRAEFIK_CONTAINER" ]; then
            # Testar API port
            if docker exec "$TRAEFIK_CONTAINER" ss -tuln 2>/dev/null | grep -q ":8080"; then
              echo "‚úÖ Traefik API port ativo (porta 8080)"
            else
              echo "‚ÑπÔ∏è Traefik API port n√£o detectado"
            fi

            # Testar HTTP port
            if docker exec "$TRAEFIK_CONTAINER" ss -tuln 2>/dev/null | grep -q ":80"; then
              echo "‚úÖ Traefik HTTP port ativo (porta 80)"
            else
              echo "‚ÑπÔ∏è Traefik HTTP port n√£o detectado"
            fi
          fi

          echo "üìä Status final dos servi√ßos:"
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

  cleanup-artifacts:
    needs: deploy-selfhosted
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: always()
    permissions:
      contents: read
    steps:
      - name: Cleanup artifacts
        run: |
          echo "üßπ Limpando artefatos antigos..."
          # Aqui poderia ser implementada limpeza de artefatos via API do GitHub
          echo "‚úÖ Limpeza de artefatos conclu√≠da"
