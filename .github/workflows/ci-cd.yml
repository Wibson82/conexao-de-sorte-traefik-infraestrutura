name: "üèóÔ∏è Infrastructure Component - CI/CD Pipeline"

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  INFRA_TYPE: infrastructure
  KUBECTL_VERSION: 'v1.28.0'
  STACK_NAME: conexao-traefik

permissions:
  contents: read
  security-events: write

jobs:
  validate:
    name: "üîç Validate Infrastructure Component"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: "üì• Checkout Repository"
        uses: actions/checkout@v4
        
      - name: "üîß Setup kubectl"
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}
          
      - name: "üìã Validate YAML Files"
        run: |
          echo "üìã Validating YAML syntax..."
          yaml_count=0
          error_count=0

          # Instalar yamllint para valida√ß√£o adequada
          pip install yamllint

          for file in $(find . -name "*.yaml" -o -name "*.yml" | grep -v ".github" | grep -v "backup" | grep -v "examples"); do
            echo "Validating: $file"
            yaml_count=$((yaml_count + 1))

            # Usar yamllint em vez de kubectl para arquivos Docker Compose (apenas erros cr√≠ticos)
            if [[ "$file" == *"docker-compose"* ]] || [[ "$file" == *"traefik"* ]]; then
              if ! yamllint -d "{extends: relaxed, rules: {line-length: disable, empty-lines: disable}}" "$file" >/dev/null 2>&1; then
                echo "‚ùå YAML syntax error in: $file"
                error_count=$((error_count + 1))
              fi
            elif [[ "$file" == *"k8s/"* ]] || [[ "$file" == *"kubernetes/"* ]]; then
              # Apenas aplicar kubectl em arquivos realmente Kubernetes
              if ! kubectl --dry-run=client apply -f "$file" 2>/dev/null; then
                echo "‚ö†Ô∏è Kubernetes validation warning: $file"
              fi
            else
              # Valida√ß√£o geral de sintaxe YAML
              if ! python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null; then
                echo "‚ùå YAML syntax error in: $file"
                error_count=$((error_count + 1))
              fi
            fi
          done

          echo "‚úÖ Validated $yaml_count YAML files"
          if [ $error_count -gt 0 ]; then
            echo "‚ùå Found $error_count YAML syntax errors"
            exit 1
          fi
          
      - name: "üîí Security Validation"
        run: |
          echo "üîí Checking for security issues..."

          # Simple and focused security check
          echo "üìã Checking for obvious security issues..."

          # Check for extremely dangerous patterns only
          dangerous_patterns_found=false

          if find . -name "*.yaml" -o -name "*.yml" | grep -v "\.github" | xargs grep -i "password: admin" 2>/dev/null; then
            echo "‚ùå Found 'password: admin' - extremely dangerous!"
            dangerous_patterns_found=true
          fi

          if find . -name "*.yaml" -o -name "*.yml" | grep -v "\.github" | xargs grep -i "password: root" 2>/dev/null; then
            echo "‚ùå Found 'password: root' - extremely dangerous!"
            dangerous_patterns_found=true
          fi

          if find . -name "*.yaml" -o -name "*.yml" | grep -v "\.github" | xargs grep -i "password: 123456" 2>/dev/null; then
            echo "‚ùå Found 'password: 123456' - extremely dangerous!"
            dangerous_patterns_found=true
          fi

          if [[ "$dangerous_patterns_found" == "true" ]]; then
            echo "‚ùå Critical security issues found!"
            exit 1
          fi

          echo "‚úÖ Security validation passed - no critical issues found"
          
      - name: "üß™ Test Scripts"
        run: |
          echo "üß™ Testing executable scripts..."
          
          script_count=0
          for script in $(find . -name "*.sh"); do
            echo "Testing: $script"
            script_count=$((script_count + 1))
            if ! bash -n "$script"; then
              echo "‚ùå Syntax error in $script"
              exit 1
            fi
          done
          
          if [ $script_count -eq 0 ]; then
            echo "‚ÑπÔ∏è No shell scripts found"
          else
            echo "‚úÖ All $script_count scripts have valid syntax"
          fi
          
      - name: "üìã Validate Documentation"
        run: |
          echo "üìã Checking documentation..."
          
          if [ ! -f "README.md" ]; then
            echo "‚ùå README.md not found"
            exit 1
          fi
          
          if [ ! -f ".gitignore" ]; then
            echo "‚ö†Ô∏è .gitignore not found"
          fi
          
          echo "‚úÖ Documentation validation passed"
          
      - name: "üìä Generate Report"
        run: |
          echo "üìä Infrastructure Component Validation Report"
          echo "=================================================="
          echo "Project: conexao-de-sorte-traefik-infraestrutura"
          echo "Type: infrastructure"
          echo "YAML files: $(find . -name "*.yaml" -o -name "*.yml" | grep -v ".github" | wc -l)"
          echo "Scripts: $(find . -name "*.sh" | wc -l)"
          echo "Status: ‚úÖ Validation Passed"

  # ============================================================================
  # üöÄ DEPLOY JOB - SELF-HOSTED RUNNER
  # ============================================================================
  deploy-selfhosted:
    name: "üöÄ Deploy to Self-Hosted Server"
    runs-on: [self-hosted, Linux, X64, conexao-de-sorte-traefik-infraestrutura]
    needs: [validate]
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 10

    steps:
      - name: "üì• Checkout Repository"
        uses: actions/checkout@v4

      - name: "üê≥ Deploy Traefik Infrastructure"
        run: |
          echo "üöÄ Deploying Traefik Infrastructure with Log Server..."

          STACK_NAME="${STACK_NAME:-conexao-traefik}"
          LEGACY_STACK="traefik-stack"

          # Create required volumes if they don't exist
          echo "üì¶ Creating required volumes..."
          docker volume create --name=traefik-logs || echo "Volume traefik-logs already exists"
          docker volume create --name=letsencrypt || echo "Volume letsencrypt already exists"

          # Create network if it doesn't exist
          echo "üåê Creating Swarm network..."
          docker network create --driver overlay --attachable conexao-network-swarm || echo "Network already exists"

          # Create secrets if they don't exist
          echo "üîê Creating basic auth secret..."
          echo "admin:$(openssl passwd -apr1 'admin123')" | docker secret create traefik_basicauth_secret - || echo "Secret already exists"

          # Limpeza de recursos legados para poupar espa√ßo
          echo "üßπ Limpando recursos legados..."

          # Limpar imagens √≥rf√£s e n√£o utilizadas
          docker image prune -f || echo "Falha ao limpar imagens √≥rf√£s"

          # Limpar containers parados antigos
          docker container prune -f || echo "Falha ao limpar containers parados"

          # Limpar volumes n√£o utilizados
          docker volume prune -f || echo "Falha ao limpar volumes √≥rf√£os"

          # Limpar networks n√£o utilizadas
          docker network prune -f || echo "Falha ao limpar networks √≥rf√£s"

          # Remover imagens antigas do log-server se existirem
          docker images --format "{{.Repository}}:{{.Tag}} {{.ID}}" | grep "log-server" | grep -v "latest" | awk '{print $2}' | xargs -r docker rmi -f || echo "Nenhuma imagem log-server antiga para remover"

          echo "‚úÖ Limpeza de legado conclu√≠da"

          # Stop existing services safely
          echo "‚èπÔ∏è Stopping existing Traefik services..."
          if docker stack ls --format '{{.Name}}' | grep -q "^${STACK_NAME}$"; then
            docker stack rm "$STACK_NAME" >/dev/null 2>&1 || true
          fi

          if [[ "$LEGACY_STACK" != "$STACK_NAME" ]] && docker stack ls --format '{{.Name}}' | grep -q "^${LEGACY_STACK}$"; then
            docker stack rm "$LEGACY_STACK" >/dev/null 2>&1 || true
          fi

          echo "‚è≥ Waiting for previous stack shutdown..."
          for attempt in {1..12}; do
            if ! docker stack ls --format '{{.Name}}' | grep -Eq "^(${STACK_NAME}|${LEGACY_STACK})$"; then
              echo "‚úÖ Previous stacks removed"
              break
            fi

            if [[ $attempt -eq 12 ]]; then
              echo "‚ùå Previous stack removal timed out"
              docker stack ls
              exit 1
            fi

            echo "‚è≥ Attempt ${attempt}/12 - stacks still shutting down..."
            sleep 10
          done

          # Remove orphaned containers
          echo "üßπ Cleaning up containers..."
          docker ps -a --filter name=traefik --format "{{.ID}}" | xargs -r docker rm -f || true

          # Deploy the stack with log server
          echo "üèóÔ∏è Deploying Traefik stack with Log Server..."
          docker stack deploy -c docker-compose.yml "$STACK_NAME" --with-registry-auth

          # Wait for services to start
          echo "‚è≥ Waiting for services to initialize..."
          sleep 30

          # Verify deployment
          echo "üîç Verifying deployment..."
          docker service ls --filter name="${STACK_NAME}"

          # Check health of critical services
          echo "üè• Checking service health..."
          for service in traefik log-server health-monitor; do
            if docker service ls --filter name="${STACK_NAME}_${service}" --format "{{.Name}}" | grep -q .; then
              echo "‚úÖ Service ${service} deployed"
            else
              echo "‚ö†Ô∏è Service ${service} not found"
            fi
          done

          echo "‚è≥ Ensuring ${STACK_NAME}_traefik reaches running state..."
          for attempt in {1..12}; do
            current_state=$(docker service ps "${STACK_NAME}_traefik" --no-trunc --format "{{.CurrentState}}" | head -n 1)
            if echo "$current_state" | grep -qi "running"; then
              echo "‚úÖ Traefik service running (${current_state})"
              break
            fi

            if [[ $attempt -eq 12 ]]; then
              echo "‚ùå Traefik service failed to reach running state"
              docker service ps "${STACK_NAME}_traefik"
              echo "üîé Capturing last logs for ${STACK_NAME}_traefik"
              docker service logs "${STACK_NAME}_traefik" --tail 200 || true
              exit 1
            fi

            echo "‚è≥ Attempt ${attempt}/12 - current state: ${current_state:-unknown}. Retrying in 10s..."
            sleep 10
          done

      - name: "üìä Post-Deploy Verification"
        run: |
          echo "üìä Post-deployment verification..."

          STACK_NAME="${STACK_NAME:-conexao-traefik}"
          FRONTEND_DOMAINS=("conexaodesorte.com.br" "www.conexaodesorte.com.br")
          domain_failure=false

          # Wait a bit more for health checks
          sleep 60

          # Validate deployment on self-hosted server
          echo "üèóÔ∏è Validating deployment on self-hosted runner:"
          echo "üìç Runner: ${{ runner.name }}"
          echo "üìç OS: ${{ runner.os }}"
          echo "üìç Architecture: ${{ runner.arch }}"

          # Check running containers
          echo "üê≥ Running containers on server:"
          docker ps --filter name="${STACK_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

          # Validate Docker Swarm services
          echo "üîç Docker Swarm services:"
          docker service ls --filter name="${STACK_NAME}"

          # Count deployed services
          service_count=$(docker service ls --filter name="${STACK_NAME}" --quiet | wc -l)
          echo "üìä Total services deployed: $service_count"

          if [[ $service_count -gt 0 ]]; then
            echo "‚úÖ Services successfully deployed to self-hosted server!"
          else
            echo "‚ùå No services found - deployment may have failed"
            exit 1
          fi

          # Test critical endpoints (if accessible locally on runner)
          echo "üåê Testing endpoints on runner..."

          # Test log server health
          if curl -f http://localhost:9090/health 2>/dev/null; then
            echo "‚úÖ Log server health endpoint responding on runner"
          else
            echo "‚ö†Ô∏è Log server not accessible on runner port 9090"
          fi

          # Validate public domains for the React frontend
          echo "üåê Validating public domains..."
          for domain in "${FRONTEND_DOMAINS[@]}"; do
            status=$(curl --silent --location --max-time 20 -o /dev/null -w '%{http_code}' "https://${domain}" || echo "000")
            if [[ $status =~ ^[23][0-9]{2}$ ]]; then
              echo "‚úÖ Domain ${domain} reachable (HTTP ${status})"
            else
              echo "‚ùå Domain ${domain} not reachable (HTTP ${status})"
              domain_failure=true
            fi
          done

          # Check if Traefik is binding ports
          if netstat -tlnp 2>/dev/null | grep -E ':80|:443' | head -3; then
            echo "‚úÖ Traefik ports (80/443) are bound on server"
          else
            echo "‚ö†Ô∏è Traefik ports not detected (may be starting up)"
          fi

          if [[ "$domain_failure" == true ]]; then
            echo "‚ùå One or more frontend domains are unreachable. Failing pipeline."
            echo "üîé Capturing Traefik logs for debugging..."
            docker service logs "${STACK_NAME}_traefik" --tail 200 || true
            echo "üîé Capturing health-monitor logs for debugging..."
            docker service logs "${STACK_NAME}_health-monitor" --tail 200 || true
            exit 1
          fi

          echo "üéâ Deployment verification completed on server runner!"
          echo "üåê Services should be accessible via: conexaodesorte.com.br"

  summary:
    name: "üìä Pipeline Summary"
    runs-on: ubuntu-latest
    needs: [validate, deploy-selfhosted]
    if: always()
    timeout-minutes: 2
    
    steps:
      - name: "üìä Generate Summary"
        run: |
          echo "## üèóÔ∏è Infrastructure Component Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Validate | ${{ needs.validate.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy | ${{ needs.deploy-selfhosted.result == 'success' && '‚úÖ Deployed' || needs.deploy-selfhosted.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Project:** conexao-de-sorte-traefik-infraestrutura" >> $GITHUB_STEP_SUMMARY
          echo "**Type:** infrastructure" >> $GITHUB_STEP_SUMMARY
          echo "**Date:** $(date '+%Y-%m-%d %H:%M:%S')" >> $GITHUB_STEP_SUMMARY
