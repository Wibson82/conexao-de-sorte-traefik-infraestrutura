name: "üõ°Ô∏è Traefik Infrastructure ‚Äì Hardened CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  SERVICE_NAME: traefik-infrastructure
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/traefik-config

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # üîç ETAPA 1: VALIDA√á√ÉO DE AMBIENTE
  # ============================================================================
  validate-environment:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      cache-key: ${{ steps.cache-key.outputs.cache-key }}
    steps:
      - name: "üì• Checkout repository"
        uses: actions/checkout@v4.3.0

      - name: "üîß Setup cache key"
        id: cache-key
        run: |
          CACHE_KEY="${{ vars.CACHE_KEY_PREFIX || 'traefik' }}-${{ hashFiles('docker-compose.yml', 'traefik/**', '.env.ci') }}"
          echo "cache-key=$CACHE_KEY" >> "$GITHUB_OUTPUT"
          echo "üìã Cache key: $CACHE_KEY"

      - name: "üìã Validate required files"
        run: |
          echo "üîç Validando arquivos obrigat√≥rios..."

          required_files=(
            "docker-compose.yml"
            "traefik/traefik.yml"
            "traefik/dynamic/microservices-routes.yml"
            "traefik/dynamic/frontend-routes.yml"
            "traefik/dynamic/middlewares.yml"
            ".env.ci"
          )

          missing_files=()
          for file in "${required_files[@]}"; do
            if [[ ! -f "$file" ]]; then
              missing_files+=("$file")
            fi
          done

          if [[ ${#missing_files[@]} -gt 0 ]]; then
            echo "‚ùå Arquivos obrigat√≥rios faltando:"
            printf '  - %s\n' "${missing_files[@]}"
            exit 1
          fi

          echo "‚úÖ Todos os arquivos obrigat√≥rios encontrados"

      - name: "üîß Install validation dependencies"
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml yamllint

      - name: "üß™ Validate Traefik configurations"
        run: |
          echo "üîç Validando sintaxe YAML..."

          yaml_files=(
            "docker-compose.yml"
            "traefik/traefik.yml"
            "traefik/dynamic/*.yml"
          )

          for pattern in "${yaml_files[@]}"; do
            for file in $pattern; do
              if [[ -f "$file" ]]; then
                echo "  Validando: $file"
                yamllint -d '{extends: default, rules: {line-length: {max: 120}}}' "$file"
              fi
            done
          done

          echo "‚úÖ Valida√ß√£o YAML conclu√≠da"

      - name: "üõ°Ô∏è Security validation"
        run: |
          echo "üîç Verificando configura√ß√µes de seguran√ßa..."

          # Verificar se n√£o h√° senhas hardcoded
          if grep -r "password\|secret\|key" --include="*.yml" --include="*.yaml" . | grep -v "# "; then
            echo "‚ö†Ô∏è Poss√≠veis segredos encontrados nos arquivos"
            echo "üîç Verifica√ß√£o manual necess√°ria"
          fi

          # Verificar SSL obrigat√≥rio
          if ! grep -q "entryPoint.*websecure" traefik/dynamic/*.yml; then
            echo "‚ùå SSL/HTTPS n√£o est√° obrigat√≥rio"
            exit 1
          fi

          echo "‚úÖ Valida√ß√£o de seguran√ßa conclu√≠da"

      - name: "üì¶ Upload validated configs"
        uses: actions/upload-artifact@v4.5.0
        with:
          name: traefik-configs-${{ github.run_id }}
          path: |
            docker-compose.yml
            .env.ci
            traefik/
            letsencrypt/
            secrets/
          retention-days: 1  # Limpeza agressiva

  # ============================================================================
  # üßπ ETAPA 2: LIMPEZA INTELIGENTE DO GHCR
  # ============================================================================
  cleanup-ghcr:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main'
    permissions:
      packages: write
      contents: read
    steps:
      - name: "üì• Checkout repository"
        uses: actions/checkout@v4.3.0

      - name: "üîë Login to GHCR"
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: "üßπ Limpeza inteligente do GHCR"
        env:
          MAX_VERSIONS_TO_KEEP: ${{ vars.MAX_VERSIONS_TO_KEEP || '3' }}
          MAX_AGE_DAYS: ${{ vars.MAX_AGE_DAYS || '7' }}
          PROTECTED_TAGS: ${{ vars.PROTECTED_TAGS || 'latest,main,production' }}
        shell: bash
        run: |
          cleanup_ghcr_safe() {
            local package_name="$1"
            local simulate="${2:-false}"

            echo "üßπ Iniciando limpeza do package: $package_name"
            echo "üìä Configura√ß√£o:"
            echo "  - Manter vers√µes: $MAX_VERSIONS_TO_KEEP"
            echo "  - Idade m√°xima: $MAX_AGE_DAYS dias"
            echo "  - Tags protegidas: $PROTECTED_TAGS"
            echo "  - Modo simula√ß√£o: $simulate"

            # Converter PROTECTED_TAGS em array
            IFS=',' read -ra protected_array <<< "$PROTECTED_TAGS"

            # Buscar todas as vers√µes
            echo "üîç Buscando vers√µes do package..."

            # Buscar via API do GitHub
            versions=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/user/packages/container/$package_name/versions" | \
              jq -r '.[] | select(.metadata.container.tags | length > 0) | {id, tags: .metadata.container.tags, created_at}')

            if [[ -z "$versions" ]] || [[ "$versions" == "null" ]]; then
              echo "‚ÑπÔ∏è Nenhuma vers√£o encontrada para limpeza"
              return 0
            fi

            echo "üìã Vers√µes encontradas:"
            echo "$versions" | jq -r '"  - ID: \(.id), Tags: \(.tags | join(",")), Created: \(.created_at)"'

            # Calcular data limite
            cutoff_date=$(date -d "$MAX_AGE_DAYS days ago" -u +"%Y-%m-%dT%H:%M:%SZ")
            echo "üìÖ Data limite: $cutoff_date"

            deleted_count=0
            protected_count=0
            recent_count=0

            # Processar cada vers√£o
            echo "$versions" | jq -c '.' | while read -r version; do
              version_id=$(echo "$version" | jq -r '.id')
              tags=$(echo "$version" | jq -r '.tags[]' 2>/dev/null || echo "")
              created_at=$(echo "$version" | jq -r '.created_at')

              # Verificar se √© tag protegida
              is_protected=false
              for tag in $tags; do
                for protected in "${protected_array[@]}"; do
                  if [[ "$tag" == "$protected" ]]; then
                    is_protected=true
                    break 2
                  fi
                done
              done

              if [[ "$is_protected" == "true" ]]; then
                echo "üõ°Ô∏è Protegida: ID=$version_id, Tags=[$tags]"
                ((protected_count++))
                continue
              fi

              # Verificar idade
              if [[ "$created_at" > "$cutoff_date" ]]; then
                echo "‚è∞ Recente: ID=$version_id, Tags=[$tags], Created=$created_at"
                ((recent_count++))
                continue
              fi

              # Candidata √† exclus√£o
              if [[ "$simulate" == "false" ]]; then
                echo "üóëÔ∏è Deletando: ID=$version_id, Tags=[$tags], Created=$created_at"

                delete_response=$(curl -s -w "%{http_code}" -o /dev/null \
                  -X DELETE \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  "https://api.github.com/user/packages/container/$package_name/versions/$version_id")

                if [[ "$delete_response" -eq 204 ]]; then
                  echo "‚úÖ Deletada com sucesso: ID=$version_id"
                  ((deleted_count++))
                else
                  echo "‚ùå Erro ao deletar ID=$version_id (HTTP: $delete_response)"
                fi
              else
                echo "üîç SIMULA√á√ÉO - Seria deletada: ID=$version_id, Tags=[$tags]"
                ((deleted_count++))
              fi
            done

            # Relat√≥rio final
            echo ""
            echo "üìä RELAT√ìRIO DE LIMPEZA:"
            echo "  üõ°Ô∏è Vers√µes protegidas: $protected_count"
            echo "  ‚è∞ Vers√µes recentes: $recent_count"
            echo "  üóëÔ∏è Vers√µes $([ "$simulate" == "true" ] && echo "que seriam" || echo "") removidas: $deleted_count"

            if [[ "$simulate" == "false" ]] && [[ $deleted_count -gt 0 ]]; then
              echo "‚úÖ Limpeza conclu√≠da com sucesso!"
            elif [[ "$simulate" == "true" ]]; then
              echo "üîç Simula√ß√£o conclu√≠da - nenhuma altera√ß√£o feita"
            else
              echo "‚ÑπÔ∏è Nenhuma limpeza necess√°ria"
            fi
          }

          # Extrair nome do package do repository
          package_name=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]' | sed 's|.*/||')

          # Executar limpeza em modo simula√ß√£o primeiro
          echo "üîç EXECUTANDO SIMULA√á√ÉO PRIMEIRO:"
          cleanup_ghcr_safe "$package_name" "true"

          echo ""
          echo "üöÄ EXECUTANDO LIMPEZA REAL:"
          cleanup_ghcr_safe "$package_name" "false"

  # ============================================================================
  # üöÄ ETAPA 3: DEPLOY COM OIDC + KEY VAULT SELETIVO
  # ============================================================================
  deploy-selfhosted:
    needs: [validate-environment, cleanup-ghcr]
    runs-on: [self-hosted, Linux, X64, conexao, conexao-de-sorte-traefik-infraestrutura]
    timeout-minutes: 20
    if: github.ref == 'refs/heads/main'
    permissions:
      id-token: write
      contents: read
    env:
      DOCKER_NETWORK_NAME: conexao-network-swarm
      STACK_NAME: conexao-traefik
      COMPOSE_FILE: docker-compose.yml
    steps:
      - name: "üì• Checkout repository"
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: "üì¶ Download validated configs"
        uses: actions/download-artifact@v4.1.8
        with:
          name: traefik-configs-${{ github.run_id }}
          path: .

      - name: "üîë Azure OIDC Login"
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: "üîê Buscar segredos espec√≠ficos do Key Vault"
        env:
          AZURE_KEYVAULT_NAME: ${{ vars.AZURE_KEYVAULT_NAME }}
        shell: bash
        run: |
          echo "üîç Buscando apenas segredos necess√°rios para Traefik..."

          # Lista espec√≠fica de segredos necess√°rios
          required_secrets=(
            "TRAEFIK-BASICAUTH-USERS"
            "TRAEFIK-API-DASHBOARD-USER"
            "TRAEFIK-ACME-EMAIL"
            "LETSENCRYPT-STAGING"
          )

          # Buscar apenas os segredos necess√°rios
          for secret_name in "${required_secrets[@]}"; do
            echo "üîë Buscando: $secret_name"

            secret_value=$(az keyvault secret show \
              --vault-name "$AZURE_KEYVAULT_NAME" \
              --name "$secret_name" \
              --query "value" \
              --output tsv 2>/dev/null)

            if [[ -n "$secret_value" ]] && [[ "$secret_value" != "null" ]]; then
              # Converter nome para vari√°vel de ambiente (- para _)
              env_var_name=$(echo "$secret_name" | tr '-' '_')
              echo "‚úÖ Encontrado: $secret_name ‚Üí $env_var_name"

              # Exportar para uso nos pr√≥ximos steps (sem mostrar valor)
              echo "$env_var_name<<EOF" >> $GITHUB_ENV
              echo "$secret_value" >> $GITHUB_ENV
              echo "EOF" >> $GITHUB_ENV
            else
              echo "‚ùå Segredo n√£o encontrado: $secret_name"
              exit 1
            fi
          done

          echo "‚úÖ Todos os segredos necess√°rios carregados"

      - name: "üê≥ Criar Docker Secrets"
        shell: bash
        run: |
          echo "üîß Criando Docker Secrets para o Swarm..."

          # Fun√ß√£o para criar secret com valida√ß√£o
          create_docker_secret() {
            local secret_name="$1"
            local secret_value="$2"

            if [[ -z "$secret_value" ]]; then
              echo "‚ùå Valor vazio para secret: $secret_name"
              return 1
            fi

            # Verificar se secret j√° existe
            if docker secret ls | grep -q "$secret_name"; then
              echo "üîÑ Removendo secret existente: $secret_name"
              docker secret rm "$secret_name" || true
            fi

            # Criar novo secret
            echo "‚úÖ Criando secret: $secret_name"
            echo "$secret_value" | docker secret create "$secret_name" - || {
              echo "‚ùå Erro ao criar secret: $secret_name"
              return 1
            }
          }

          # Criar todos os secrets necess√°rios
          create_docker_secret "traefik-basicauth-users" "$TRAEFIK_BASICAUTH_USERS"
          create_docker_secret "traefik-api-dashboard-user" "$TRAEFIK_API_DASHBOARD_USER"
          create_docker_secret "traefik-acme-email" "$TRAEFIK_ACME_EMAIL"
          create_docker_secret "letsencrypt-staging" "$LETSENCRYPT_STAGING"

          echo "‚úÖ Todos os Docker Secrets criados com sucesso"

      - name: "üîß Preparar ambiente"
        run: |
          echo "üîß Preparando ambiente de deploy..."

          # Usar arquivo de ambiente espec√≠fico para CI/CD
          cp .env.ci .env

          # Criar diret√≥rios necess√°rios
          mkdir -p secrets letsencrypt traefik/dynamic

          # Criar arquivo de autentica√ß√£o se n√£o existir
          if [[ ! -f "secrets/traefik-basicauth" ]]; then
            echo "üîë Criando arquivo de autentica√ß√£o b√°sica..."
            # Usar o secret do Azure Key Vault para criar o arquivo
            echo "$TRAEFIK_BASICAUTH_USERS" > secrets/traefik-basicauth
            chmod 600 secrets/traefik-basicauth
            echo "‚úÖ Arquivo traefik-basicauth criado"
          fi

          # Configurar acme.json
          if [[ ! -f "letsencrypt/acme.json" ]]; then
            echo "{}" > letsencrypt/acme.json
            chmod 600 letsencrypt/acme.json
            echo "‚úÖ Arquivo acme.json criado"
          fi

          # Verificar se rede Swarm existe
          if ! docker network ls | grep -q "$DOCKER_NETWORK_NAME"; then
            echo "üåê Criando rede Docker Swarm: $DOCKER_NETWORK_NAME"
            docker network create --driver overlay "$DOCKER_NETWORK_NAME"
          else
            echo "‚úÖ Rede Docker Swarm j√° existe: $DOCKER_NETWORK_NAME"
          fi

          echo "‚úÖ Ambiente preparado"

      - name: "üöÄ Deploy Traefik Stack"
        env:
          STACK_NAME: conexao-traefik
          COMPOSE_FILE: docker-compose.yml
        shell: bash
        run: |
          echo "üöÄ Iniciando deploy do Traefik com Docker Swarm..."
          echo "üìÅ Arquivo: $COMPOSE_FILE"
          echo "üè∑Ô∏è Stack: $STACK_NAME"

          # Validar arquivo compose
          if ! docker compose -f "$COMPOSE_FILE" config > /dev/null 2>&1; then
            echo "‚ùå Erro na valida√ß√£o do docker-compose.yml"
            docker compose -f "$COMPOSE_FILE" config
            exit 1
          fi

          echo "‚úÖ Arquivo docker-compose v√°lido"

          # Deploy da stack
          echo "üöÄ Executando deploy..."
          docker stack deploy -c "$COMPOSE_FILE" "$STACK_NAME"

          # Aguardar converg√™ncia
          echo "‚è≥ Aguardando converg√™ncia da stack..."
          sleep 30

          # Verificar status dos servi√ßos
          echo "üìä Status dos servi√ßos:"
          docker stack services "$STACK_NAME"

          echo "‚úÖ Deploy conclu√≠do"

      - name: "üè• Health check"
        env:
          STACK_NAME: conexao-traefik
        shell: bash
        run: |
          echo "üè• Verificando sa√∫de do Traefik..."

          max_attempts=10
          attempt=1

          while [[ $attempt -le $max_attempts ]]; do
            echo "üîç Tentativa $attempt/$max_attempts"

            # Verificar se o servi√ßo est√° rodando
            if docker service ps "${STACK_NAME}_traefik" --format "table {{.CurrentState}}" | grep -q "Running"; then
              echo "‚úÖ Servi√ßo Traefik est√° rodando"

              # Teste de conectividade local
              if curl -f -s http://localhost:8080/ping > /dev/null 2>&1; then
                echo "‚úÖ Traefik respondendo na porta 8080"
                break
              else
                echo "‚ö†Ô∏è Traefik n√£o respondendo ainda na porta 8080"
              fi
            else
              echo "‚ö†Ô∏è Servi√ßo Traefik ainda n√£o est√° rodando"
            fi

            if [[ $attempt -eq $max_attempts ]]; then
              echo "‚ùå Health check falhou ap√≥s $max_attempts tentativas"
              echo "üìä Status detalhado:"
              docker service ps "${STACK_NAME}_traefik"
              docker service logs "${STACK_NAME}_traefik" --tail 50
              exit 1
            fi

            sleep 10
            ((attempt++))
          done

          echo "‚úÖ Health check bem-sucedido"

      - name: "üåê Connectivity validation"
        shell: bash
        run: |
          echo "üåê Validando conectividade..."

          # Verificar se as portas est√£o abertas
          ports=(80 443 8080)

          for port in "${ports[@]}"; do
            echo "üîç Verificando porta $port..."

            if netstat -tln | grep -q ":$port "; then
              echo "‚úÖ Porta $port est√° aberta"
            else
              echo "‚ö†Ô∏è Porta $port n√£o est√° aberta"
            fi
          done

          # Verificar DNS interno
          echo "üîç Verificando resolu√ß√£o DNS interna..."

          if nslookup traefik > /dev/null 2>&1; then
            echo "‚úÖ DNS interno funcionando"
          else
            echo "‚ö†Ô∏è Problema com DNS interno"
          fi

          echo "‚úÖ Valida√ß√£o de conectividade conclu√≠da"

      - name: "üßπ Limpeza p√≥s-deploy"
        shell: bash
        run: |
          echo "üßπ Executando limpeza p√≥s-deploy..."

          # Remover imagens antigas (manter apenas as 2 mais recentes)
          echo "üóëÔ∏è Removendo imagens antigas..."
          docker image prune -f --filter "until=72h" || true

          # Remover containers parados
          echo "üóëÔ∏è Removendo containers parados..."
          docker container prune -f || true

          # Remover volumes √≥rf√£os (cuidado!)
          echo "üóëÔ∏è Removendo volumes √≥rf√£os..."
          docker volume prune -f || true

          echo "‚úÖ Limpeza conclu√≠da"

  # ============================================================================
  # üßπ ETAPA 4: LIMPEZA DE ARTEFATOS
  # ============================================================================
  cleanup-artifacts:
    needs: [deploy-selfhosted]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: always() && github.ref == 'refs/heads/main'
    permissions:
      actions: write
      contents: read
    steps:
      - name: "üßπ Limpar artefatos tempor√°rios"
        shell: bash
        run: |
          echo "üßπ Limpando artefatos do workflow atual..."

          # Buscar artefatos do workflow atual
          artifacts=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" | \
            jq -r '.artifacts[] | select(.name | startswith("traefik-configs-")) | .id')

          if [[ -n "$artifacts" ]]; then
            echo "üóëÔ∏è Encontrados artefatos para limpeza:"

            for artifact_id in $artifacts; do
              echo "  - Deletando artifact ID: $artifact_id"

              response=$(curl -s -w "%{http_code}" -o /dev/null \
                -X DELETE \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$artifact_id")

              if [[ "$response" -eq 204 ]]; then
                echo "    ‚úÖ Deletado com sucesso"
              else
                echo "    ‚ö†Ô∏è Erro ao deletar (HTTP: $response)"
              fi
            done
          else
            echo "‚ÑπÔ∏è Nenhum artefato tempor√°rio encontrado para limpeza"
          fi

          echo "‚úÖ Limpeza de artefatos conclu√≠da"