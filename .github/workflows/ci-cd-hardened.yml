name: "ğŸ›¡ï¸ Traefik Infrastructure â€“ Hardened CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  SERVICE_NAME: traefik-infrastructure
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/traefik-config

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # ğŸ”„ PIPELINE LINEAR - EXECUÃ‡ÃƒO SEQUENCIAL
  # ============================================================================
  # Estrutura: validate â†’ cleanup-ghcr â†’ deploy â†’ cleanup-artifacts
  # Motivo: Evitar condiÃ§Ãµes de corrida e facilitar debugging
  # ============================================================================

  # ============================================================================
  # ğŸ” ETAPA 1: VALIDAÃ‡ÃƒO DE AMBIENTE
  # ============================================================================
  validate-environment:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      cache-key: ${{ steps.cache-key.outputs.cache-key }}
    steps:
      - name: "ğŸ“¥ Checkout repository"
        uses: actions/checkout@v4.3.0

      - name: "ğŸ”§ Setup cache key"
        id: cache-key
        run: |
          CACHE_KEY="${{ vars.CACHE_KEY_PREFIX || 'traefik' }}-${{ hashFiles('docker-compose.yml', 'traefik/**', '.env.ci') }}"
          echo "cache-key=$CACHE_KEY" >> "$GITHUB_OUTPUT"
          echo "ğŸ“‹ Cache key: $CACHE_KEY"

      - name: "ğŸ“‹ Validate required files"
        run: |
          echo "ğŸ” Validando arquivos obrigatÃ³rios..."

          required_files=(
            "docker-compose.yml"
            "traefik/traefik.yml"
            "traefik/dynamic/microservices-routes.yml"
            "traefik/dynamic/frontend-routes.yml"
            "traefik/dynamic/middlewares.yml"
            ".env.ci"
          )

          missing_files=()
          for file in "${required_files[@]}"; do
            if [[ ! -f "$file" ]]; then
              missing_files+=("$file")
            fi
          done

          if [[ ${#missing_files[@]} -gt 0 ]]; then
            echo "âŒ Arquivos obrigatÃ³rios faltando:"
            printf '  - %s\n' "${missing_files[@]}"
            exit 1
          fi

          echo "âœ… Todos os arquivos obrigatÃ³rios encontrados"

      - name: "ğŸ”§ Install validation dependencies"
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml yamllint

      - name: "ğŸ§ª Validate Traefik configurations"
        run: |
          echo "ğŸ” Validando sintaxe YAML..."

          yaml_files=(
            "docker-compose.yml"
            "traefik/traefik.yml"
            "traefik/dynamic/*.yml"
          )

          # Excluir arquivos de backup da validaÃ§Ã£o
          exclude_patterns=(
            "traefik/dynamic-backup/*.yml"
            ".env*"
          )

          for pattern in "${yaml_files[@]}"; do
            for file in $pattern; do
              if [[ -f "$file" ]]; then
                # Verificar se o arquivo nÃ£o estÃ¡ na lista de exclusÃ£o
                skip_file=false
                for exclude in "${exclude_patterns[@]}"; do
                  if [[ "$file" == $exclude ]]; then
                    skip_file=true
                    break
                  fi
                done

                if [[ "$skip_file" == false ]]; then
                  echo "  Validando: $file"
                  yamllint -f parsable -d '{extends: default, rules: {line-length: {max: 120}, comments-indentation: disable}}' "$file"
                else
                  echo "  Ignorando (backup): $file"
                fi
              fi
            done
          done

          echo "âœ… ValidaÃ§Ã£o YAML concluÃ­da"

      - name: "ğŸ›¡ï¸ Security validation"
        run: |
          echo "ğŸ” Verificando configuraÃ§Ãµes de seguranÃ§a..."

          # Verificar senhas hardcoded (apenas valores reais, nÃ£o nomes de campos)
          echo "ğŸ” Procurando por possÃ­veis senhas hardcoded..."
          suspicious_patterns=(
            "password[[:space:]]*:[[:space:]]*['\"].*['\"]"
            "secret[[:space:]]*:[[:space:]]*['\"].*['\"]"
            "token[[:space:]]*:[[:space:]]*['\"].*['\"]"
          )

          found_issues=false
          for pattern in "${suspicious_patterns[@]}"; do
            if grep -r -i "$pattern" --include="*.yml" --include="*.yaml" . 2>/dev/null; then
              found_issues=true
            fi
          done

          if [[ "$found_issues" == true ]]; then
            echo "âš ï¸ PossÃ­veis credenciais hardcoded encontradas - revisar manualmente"
            # Apenas warning, nÃ£o falhar o pipeline
          else
            echo "âœ… Nenhuma credencial hardcoded detectada"
          fi

          # Verificar configuraÃ§Ã£o SSL (adaptada para configuraÃ§Ã£o mÃ­nima)
          echo "ğŸ” Verificando configuraÃ§Ã£o SSL..."
          if grep -q "address.*:443" traefik/traefik.yml; then
            echo "âœ… Entrada HTTPS configurada (porta 443)"
          else
            echo "âš ï¸ Entrada HTTPS nÃ£o encontrada em traefik.yml"
          fi

          # Verificar redirect HTTP para HTTPS
          if grep -q "scheme.*https" traefik/traefik.yml; then
            echo "âœ… Redirect HTTPâ†’HTTPS configurado"
          else
            echo "âš ï¸ Redirect HTTPâ†’HTTPS nÃ£o encontrado"
          fi

          echo "âœ… ValidaÃ§Ã£o de seguranÃ§a concluÃ­da"

      - name: "ğŸ“¦ Upload validated configs"
        uses: actions/upload-artifact@v4.5.0
        with:
          name: traefik-configs-${{ github.run_id }}
          path: |
            docker-compose.yml
            .env.ci
            traefik/
            letsencrypt/
            secrets/
          retention-days: 1  # Limpeza agressiva

      - name: "âœ… ValidaÃ§Ã£o completa"
        run: |
          echo "ğŸ‰ ETAPA 1 CONCLUÃDA: ValidaÃ§Ã£o de ambiente"
          echo "ğŸ“‹ Cache key: ${{ steps.cache-key.outputs.cache-key }}"
          echo "ğŸ”„ PrÃ³xima etapa: Limpeza GHCR (linear)"

  # ============================================================================
  # ğŸ§¹ ETAPA 2: LIMPEZA INTELIGENTE DO GHCR
  # ============================================================================
  cleanup-ghcr:
    needs: [validate-environment]  # ğŸ”„ LINEAR: Aguarda validaÃ§Ã£o completar
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main'
    permissions:
      packages: write
      contents: read
    steps:
      - name: "ğŸ“¥ Checkout repository"
        uses: actions/checkout@v4.3.0

      - name: "ğŸ”‘ Login to GHCR"
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: "ğŸ§¹ Limpeza inteligente do GHCR"
        env:
          MAX_VERSIONS_TO_KEEP: ${{ vars.MAX_VERSIONS_TO_KEEP || '3' }}
          MAX_AGE_DAYS: ${{ vars.MAX_AGE_DAYS || '7' }}
          PROTECTED_TAGS: ${{ vars.PROTECTED_TAGS || 'latest,main,production' }}
        shell: bash
        run: |
          cleanup_ghcr_safe() {
            local package_name="$1"
            local simulate="${2:-false}"

            echo "ğŸ§¹ Iniciando limpeza do package: $package_name"
            echo "ğŸ“Š ConfiguraÃ§Ã£o:"
            echo "  - Manter versÃµes: $MAX_VERSIONS_TO_KEEP"
            echo "  - Idade mÃ¡xima: $MAX_AGE_DAYS dias"
            echo "  - Tags protegidas: $PROTECTED_TAGS"
            echo "  - Modo simulaÃ§Ã£o: $simulate"

            # Converter PROTECTED_TAGS em array
            IFS=',' read -ra protected_array <<< "$PROTECTED_TAGS"

            # Buscar todas as versÃµes
            echo "ğŸ” Buscando versÃµes do package..."

            # Buscar via API do GitHub
            api_response=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/user/packages/container/$package_name/versions")

            # Verificar se a resposta Ã© um JSON vÃ¡lido
            if ! echo "$api_response" | jq empty 2>/dev/null; then
              echo "âš ï¸ Resposta da API nÃ£o Ã© JSON vÃ¡lido:"
              echo "$api_response"
              echo "â„¹ï¸ PossÃ­veis causas: package nÃ£o existe, sem permissÃµes, ou erro da API"
              echo "ğŸ”„ Continuando pipeline sem limpeza GHCR"
              return 0
            fi

            # Verificar se nÃ£o houve erro da API
            if echo "$api_response" | jq -e '.message' >/dev/null 2>&1; then
              error_msg=$(echo "$api_response" | jq -r '.message')
              echo "âš ï¸ Erro da API GitHub: $error_msg"
              echo "ğŸ”„ Continuando pipeline sem limpeza GHCR"
              return 0
            fi

            # Extrair versÃµes com tags
            versions=$(echo "$api_response" | jq -r '.[] | select(.metadata.container.tags | length > 0) | {id, tags: .metadata.container.tags, created_at}' 2>/dev/null || echo "")

            if [[ -z "$versions" ]] || [[ "$versions" == "null" ]]; then
              echo "â„¹ï¸ Nenhuma versÃ£o com tags encontrada para limpeza"
              return 0
            fi

            echo "ğŸ“‹ VersÃµes encontradas:"
            echo "$versions" | jq -r '"  - ID: \(.id), Tags: \(.tags | join(",")), Created: \(.created_at)"'

            # Calcular data limite
            cutoff_date=$(date -d "$MAX_AGE_DAYS days ago" -u +"%Y-%m-%dT%H:%M:%SZ")
            echo "ğŸ“… Data limite: $cutoff_date"

            deleted_count=0
            protected_count=0
            recent_count=0

            # Processar cada versÃ£o
            echo "$versions" | jq -c '.' | while read -r version; do
              version_id=$(echo "$version" | jq -r '.id')
              tags=$(echo "$version" | jq -r '.tags[]' 2>/dev/null || echo "")
              created_at=$(echo "$version" | jq -r '.created_at')

              # Verificar se Ã© tag protegida
              is_protected=false
              for tag in $tags; do
                for protected in "${protected_array[@]}"; do
                  if [[ "$tag" == "$protected" ]]; then
                    is_protected=true
                    break 2
                  fi
                done
              done

              if [[ "$is_protected" == "true" ]]; then
                echo "ğŸ›¡ï¸ Protegida: ID=$version_id, Tags=[$tags]"
                ((protected_count++))
                continue
              fi

              # Verificar idade
              if [[ "$created_at" > "$cutoff_date" ]]; then
                echo "â° Recente: ID=$version_id, Tags=[$tags], Created=$created_at"
                ((recent_count++))
                continue
              fi

              # Candidata Ã  exclusÃ£o
              if [[ "$simulate" == "false" ]]; then
                echo "ğŸ—‘ï¸ Deletando: ID=$version_id, Tags=[$tags], Created=$created_at"

                delete_response=$(curl -s -w "%{http_code}" -o /dev/null \
                  -X DELETE \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  "https://api.github.com/user/packages/container/$package_name/versions/$version_id")

                if [[ "$delete_response" -eq 204 ]]; then
                  echo "âœ… Deletada com sucesso: ID=$version_id"
                  ((deleted_count++))
                else
                  echo "âŒ Erro ao deletar ID=$version_id (HTTP: $delete_response)"
                fi
              else
                echo "ğŸ” SIMULAÃ‡ÃƒO - Seria deletada: ID=$version_id, Tags=[$tags]"
                ((deleted_count++))
              fi
            done

            # RelatÃ³rio final
            echo ""
            echo "ğŸ“Š RELATÃ“RIO DE LIMPEZA:"
            echo "  ğŸ›¡ï¸ VersÃµes protegidas: $protected_count"
            echo "  â° VersÃµes recentes: $recent_count"
            echo "  ğŸ—‘ï¸ VersÃµes $([ "$simulate" == "true" ] && echo "que seriam" || echo "") removidas: $deleted_count"

            if [[ "$simulate" == "false" ]] && [[ $deleted_count -gt 0 ]]; then
              echo "âœ… Limpeza concluÃ­da com sucesso!"
            elif [[ "$simulate" == "true" ]]; then
              echo "ğŸ” SimulaÃ§Ã£o concluÃ­da - nenhuma alteraÃ§Ã£o feita"
            else
              echo "â„¹ï¸ Nenhuma limpeza necessÃ¡ria"
            fi
          }

          # Extrair nome do package do repository
          package_name=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]' | sed 's|.*/||')

          # Executar limpeza em modo simulaÃ§Ã£o primeiro
          echo "ğŸ” EXECUTANDO SIMULAÃ‡ÃƒO PRIMEIRO:"
          cleanup_ghcr_safe "$package_name" "true"

          echo ""
          echo "ğŸš€ EXECUTANDO LIMPEZA REAL:"
          cleanup_ghcr_safe "$package_name" "false"

      - name: "âœ… Limpeza GHCR completa"
        run: |
          echo "ğŸ‰ ETAPA 2 CONCLUÃDA: Limpeza inteligente GHCR"
          echo "ğŸ”„ PrÃ³xima etapa: Deploy self-hosted (linear)"

  # ============================================================================
  # ğŸš€ ETAPA 3: DEPLOY COM OIDC + KEY VAULT SELETIVO
  # ============================================================================
  deploy-selfhosted:
    needs: [cleanup-ghcr]  # ğŸ”„ LINEAR: Aguarda limpeza GHCR completar
    runs-on: [self-hosted, Linux, X64, conexao, conexao-de-sorte-traefik-infraestrutura]
    timeout-minutes: 20
    if: github.ref == 'refs/heads/main'
    permissions:
      id-token: write
      contents: read
    env:
      DOCKER_NETWORK_NAME: conexao-network-swarm
      STACK_NAME: conexao-traefik
      COMPOSE_FILE: docker-compose.yml
    steps:
      - name: "ğŸ“¥ Checkout repository"
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: "ğŸ” DiagnÃ³stico inicial"
        run: |
          echo "ğŸ¯ INICIANDO ETAPA 3: Deploy self-hosted (linear)"
          echo "ğŸ• Timestamp: $(date)"
          echo "ğŸ“‹ Commit: $GITHUB_SHA"

          echo ""
          echo "ğŸ³ Estado inicial do Docker Swarm:"
          docker service ls | grep -E "(traefik|NAME)" || echo "Nenhum serviÃ§o Traefik atual"

          echo ""
          echo "ğŸ—‚ï¸ EspaÃ§o em disco:"
          df -h / | head -2

      - name: "ğŸ“¦ Download validated configs"
        uses: actions/download-artifact@v4.1.8
        with:
          name: traefik-configs-${{ github.run_id }}
          path: .

      - name: "ğŸ”‘ Azure OIDC Login"
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: "ğŸ” Buscar segredos especÃ­ficos do Key Vault"
        env:
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
        shell: bash
        run: |
          echo "ğŸ” Buscando apenas segredos necessÃ¡rios para Traefik..."

          # Lista especÃ­fica de segredos necessÃ¡rios
          required_secrets=(
            "TRAEFIK-BASICAUTH-USERS"
            "TRAEFIK-API-DASHBOARD-USER"
            "TRAEFIK-ACME-EMAIL"
            "LETSENCRYPT-STAGING"
          )

          # Buscar apenas os segredos necessÃ¡rios
          for secret_name in "${required_secrets[@]}"; do
            echo "ğŸ”‘ Buscando: $secret_name"

            secret_value=$(az keyvault secret show \
              --vault-name "$AZURE_KEYVAULT_NAME" \
              --name "$secret_name" \
              --query "value" \
              --output tsv 2>/dev/null)

            if [[ -n "$secret_value" ]] && [[ "$secret_value" != "null" ]]; then
              # Converter nome para variÃ¡vel de ambiente (- para _)
              env_var_name=$(echo "$secret_name" | tr '-' '_')
              echo "âœ… Encontrado: $secret_name â†’ $env_var_name"

              # Exportar para uso nos prÃ³ximos steps (sem mostrar valor)
              echo "$env_var_name<<EOF" >> $GITHUB_ENV
              echo "$secret_value" >> $GITHUB_ENV
              echo "EOF" >> $GITHUB_ENV
            else
              echo "âŒ Segredo nÃ£o encontrado: $secret_name"
              exit 1
            fi
          done

          echo "âœ… Todos os segredos necessÃ¡rios carregados"

      - name: "ğŸ³ Criar Docker Secrets"
        shell: bash
        run: |
          echo "ğŸ”§ Criando Docker Secrets para o Swarm..."

          # FunÃ§Ã£o para criar secret com validaÃ§Ã£o
          create_docker_secret() {
            local secret_name="$1"
            local secret_value="$2"

            if [[ -z "$secret_value" ]]; then
              echo "âŒ Valor vazio para secret: $secret_name"
              return 1
            fi

            # Verificar se secret jÃ¡ existe
            if docker secret ls | grep -q "$secret_name"; then
              echo "ğŸ”„ Removendo secret existente: $secret_name"
              docker secret rm "$secret_name" || true
            fi

            # Criar novo secret
            echo "âœ… Criando secret: $secret_name"
            echo "$secret_value" | docker secret create "$secret_name" - || {
              echo "âŒ Erro ao criar secret: $secret_name"
              return 1
            }
          }

          # Criar todos os secrets necessÃ¡rios
          create_docker_secret "traefik-basicauth-users" "$TRAEFIK_BASICAUTH_USERS"
          create_docker_secret "traefik-api-dashboard-user" "$TRAEFIK_API_DASHBOARD_USER"
          create_docker_secret "traefik-acme-email" "$TRAEFIK_ACME_EMAIL"
          create_docker_secret "letsencrypt-staging" "$LETSENCRYPT_STAGING"

          echo "âœ… Todos os Docker Secrets criados com sucesso"

      - name: "ğŸ”§ Preparar ambiente"
        run: |
          echo "ğŸ”§ Preparando ambiente de deploy..."

          # Usar arquivo de ambiente especÃ­fico para CI/CD
          cp .env.ci .env

          # Criar diretÃ³rios necessÃ¡rios
          mkdir -p secrets letsencrypt traefik/dynamic

          # Criar arquivo de autenticaÃ§Ã£o se nÃ£o existir
          if [[ ! -f "secrets/traefik-basicauth" ]]; then
            echo "ğŸ”‘ Criando arquivo de autenticaÃ§Ã£o bÃ¡sica..."
            # Usar o secret do Azure Key Vault para criar o arquivo
            echo "$TRAEFIK_BASICAUTH_USERS" > secrets/traefik-basicauth
            chmod 600 secrets/traefik-basicauth
            echo "âœ… Arquivo traefik-basicauth criado"
          fi

          # Configurar acme.json
          if [[ ! -f "letsencrypt/acme.json" ]]; then
            echo "{}" > letsencrypt/acme.json
            chmod 600 letsencrypt/acme.json
            echo "âœ… Arquivo acme.json criado"
          fi

          # Verificar se rede Swarm existe
          if ! docker network ls | grep -q "$DOCKER_NETWORK_NAME"; then
            echo "ğŸŒ Criando rede Docker Swarm: $DOCKER_NETWORK_NAME"
            docker network create --driver overlay "$DOCKER_NETWORK_NAME"
          else
            echo "âœ… Rede Docker Swarm jÃ¡ existe: $DOCKER_NETWORK_NAME"
          fi

          echo "âœ… Ambiente preparado"

      - name: "ğŸš€ Deploy Traefik Stack"
        env:
          STACK_NAME: conexao-traefik
          COMPOSE_FILE: docker-compose.yml
        shell: bash
        run: |
          echo "ğŸš€ Iniciando deploy do Traefik com Docker Swarm..."
          echo "ğŸ“ Arquivo: $COMPOSE_FILE"
          echo "ğŸ·ï¸ Stack: $STACK_NAME"

          # Validar arquivo compose
          if ! docker compose -f "$COMPOSE_FILE" config > /dev/null 2>&1; then
            echo "âŒ Erro na validaÃ§Ã£o do docker-compose.yml"
            docker compose -f "$COMPOSE_FILE" config
            exit 1
          fi

          echo "âœ… Arquivo docker-compose vÃ¡lido"

          # Deploy da stack
          echo "ğŸš€ Executando deploy..."
          docker stack deploy -c "$COMPOSE_FILE" "$STACK_NAME"

          # Aguardar convergÃªncia
          echo "â³ Aguardando convergÃªncia da stack..."
          sleep 30

          # Verificar status dos serviÃ§os
          echo "ğŸ“Š Status dos serviÃ§os:"
          docker stack services "$STACK_NAME"

          echo "âœ… Deploy concluÃ­do"

      - name: "ğŸ¥ Health check"
        env:
          STACK_NAME: conexao-traefik
        shell: bash
        run: |
          echo "ğŸ¥ Verificando saÃºde do Traefik..."

          max_attempts=10
          attempt=1

          while [[ $attempt -le $max_attempts ]]; do
            echo "ğŸ” Tentativa $attempt/$max_attempts"

            # Verificar se o serviÃ§o estÃ¡ rodando
            if docker service ps "${STACK_NAME}_traefik" --format "table {{.CurrentState}}" | grep -q "Running"; then
              echo "âœ… ServiÃ§o Traefik estÃ¡ rodando"

              # Teste de conectividade local
              if curl -f -s http://localhost:8080/ping > /dev/null 2>&1; then
                echo "âœ… Traefik respondendo na porta 8080"
                break
              else
                echo "âš ï¸ Traefik nÃ£o respondendo ainda na porta 8080"
              fi
            else
              echo "âš ï¸ ServiÃ§o Traefik ainda nÃ£o estÃ¡ rodando"
            fi

            if [[ $attempt -eq $max_attempts ]]; then
              echo "âŒ Health check falhou apÃ³s $max_attempts tentativas"
              echo "ğŸ“Š Status detalhado:"
              docker service ps "${STACK_NAME}_traefik"
              docker service logs "${STACK_NAME}_traefik" --tail 50
              exit 1
            fi

            sleep 10
            ((attempt++))
          done

          echo "âœ… Health check bem-sucedido"

      - name: "ğŸŒ Connectivity validation"
        shell: bash
        run: |
          echo "ğŸŒ Validando conectividade..."

          # Verificar se as portas estÃ£o abertas
          ports=(80 443 8080)

          for port in "${ports[@]}"; do
            echo "ğŸ” Verificando porta $port..."

            if netstat -tln | grep -q ":$port "; then
              echo "âœ… Porta $port estÃ¡ aberta"
            else
              echo "âš ï¸ Porta $port nÃ£o estÃ¡ aberta"
            fi
          done

          # Verificar DNS interno
          echo "ğŸ” Verificando resoluÃ§Ã£o DNS interna..."

          if nslookup traefik > /dev/null 2>&1; then
            echo "âœ… DNS interno funcionando"
          else
            echo "âš ï¸ Problema com DNS interno"
          fi

          echo "âœ… ValidaÃ§Ã£o de conectividade concluÃ­da"

      - name: "ğŸ§¹ Limpeza pÃ³s-deploy"
        shell: bash
        run: |
          echo "ğŸ§¹ Executando limpeza pÃ³s-deploy..."

          # Remover imagens antigas (manter apenas as 2 mais recentes)
          echo "ğŸ—‘ï¸ Removendo imagens antigas..."
          docker image prune -f --filter "until=72h" || true

          # Remover containers parados
          echo "ğŸ—‘ï¸ Removendo containers parados..."
          docker container prune -f || true

          # Remover volumes Ã³rfÃ£os (cuidado!)
          echo "ğŸ—‘ï¸ Removendo volumes Ã³rfÃ£os..."
          docker volume prune -f || true

          echo "âœ… Limpeza concluÃ­da"

      - name: "ğŸ“Š Status final do deploy"
        run: |
          echo "ğŸ” Verificando status final do Traefik..."

          # Status dos serviÃ§os
          echo "ğŸ“Š Status dos serviÃ§os:"
          docker service ls | grep -E "(traefik|NAME)" || echo "Nenhum serviÃ§o Traefik encontrado"

          # Status detalhado
          if docker service ls | grep -q "conexao-traefik_traefik"; then
            echo ""
            echo "ğŸ“‹ Status detalhado do serviÃ§o:"
            docker service ps conexao-traefik_traefik --no-trunc --format "table {{.ID}}\t{{.Name}}\t{{.Image}}\t{{.Node}}\t{{.DesiredState}}\t{{.CurrentState}}\t{{.Error}}"

            echo ""
            echo "ğŸ¥ Health check final:"
            timeout 30s bash -c 'until curl -f -s http://localhost:8080/ping > /dev/null 2>&1; do echo "â³ Aguardando Traefik..."; sleep 2; done' && echo "âœ… Traefik respondendo" || echo "âš ï¸ Timeout no health check"
          fi

      - name: "âœ… Deploy completo"
        run: |
          echo "ğŸ‰ ETAPA 3 CONCLUÃDA: Deploy self-hosted"
          echo "ğŸ”„ PrÃ³xima etapa: Limpeza de artefatos (linear)"

  # ============================================================================
  # ğŸ§¹ ETAPA 4: LIMPEZA DE ARTEFATOS
  # ============================================================================
  cleanup-artifacts:
    needs: [deploy-selfhosted]  # ğŸ”„ LINEAR: Aguarda deploy completar
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: always() && github.ref == 'refs/heads/main'
    permissions:
      actions: write
      contents: read
    steps:
      - name: "ğŸ§¹ Limpar artefatos temporÃ¡rios"
        shell: bash
        run: |
          echo "ğŸ§¹ Limpando artefatos do workflow atual..."

          # Buscar artefatos do workflow atual
          artifacts=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts" | \
            jq -r '.artifacts[] | select(.name | startswith("traefik-configs-")) | .id')

          if [[ -n "$artifacts" ]]; then
            echo "ğŸ—‘ï¸ Encontrados artefatos para limpeza:"

            for artifact_id in $artifacts; do
              echo "  - Deletando artifact ID: $artifact_id"

              response=$(curl -s -w "%{http_code}" -o /dev/null \
                -X DELETE \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/$artifact_id")

              if [[ "$response" -eq 204 ]]; then
                echo "    âœ… Deletado com sucesso"
              else
                echo "    âš ï¸ Erro ao deletar (HTTP: $response)"
              fi
            done
          else
            echo "â„¹ï¸ Nenhum artefato temporÃ¡rio encontrado para limpeza"
          fi

          echo "âœ… Limpeza de artefatos concluÃ­da"

      - name: "ğŸ‰ Pipeline linear completo"
        run: |
          echo "=================================================================="
          echo "ğŸ‰ PIPELINE HARDENED LINEAR CONCLUÃDO COM SUCESSO!"
          echo "=================================================================="
          echo "ğŸ• Timestamp final: $(date)"
          echo "ğŸ“‹ Commit deployado: $GITHUB_SHA"
          echo ""
          echo "ğŸ“Š Resumo das etapas (execuÃ§Ã£o linear):"
          echo "  1. âœ… ValidaÃ§Ã£o de ambiente"
          echo "  2. âœ… Limpeza inteligente GHCR"
          echo "  3. âœ… Deploy self-hosted com OIDC"
          echo "  4. âœ… Limpeza de artefatos"
          echo ""
          echo "ğŸŒ Traefik deve estar disponÃ­vel em:"
          echo "  ğŸ“Š Dashboard: https://traefik.conexaodesorte.com.br"
          echo "  ğŸ”— API: https://api.conexaodesorte.com.br"
          echo "=================================================================="